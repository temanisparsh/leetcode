{"link": "https://leetcode.com/problems/groups-of-special-equivalent-strings", "name": "Groups of Special-Equivalent Strings", "difficulty": "Easy", "statement": "<div><p>You are given an array <code>A</code> of strings.</p>\n\n<p>A <em>move&nbsp;onto <code>S</code></em> consists of swapping any two even indexed characters of <code>S</code>, or any two odd indexed characters of <code>S</code>.</p>\n\n<p>Two strings <code>S</code> and <code>T</code> are&nbsp;<em>special-equivalent</em>&nbsp;if after any number of <em>moves onto <code>S</code></em>, <code>S == T</code>.</p>\n\n<p>For example, <code>S = \"zzxy\"</code> and <code>T = \"xyzz\"</code> are special-equivalent because we may make the moves <code>\"zzxy\" -&gt; \"xzzy\" -&gt; \"xyzz\"</code>&nbsp;that swap <code>S[0]</code> and <code>S[2]</code>, then <code>S[1]</code> and <code>S[3]</code>.</p>\n\n<p>Now, a <em>group of special-equivalent strings from <code>A</code></em>&nbsp;is a non-empty subset of&nbsp;A such that:</p>\n\n<ol>\n\t<li>Every pair of strings in the group are special equivalent, and;</li>\n\t<li>The group is the largest size possible (ie., there isn't a string S not in the group such that S is special equivalent to every string in the group)</li>\n</ol>\n\n<p>Return the number of groups of special-equivalent strings from <code>A</code>.</p>\n\n<div>&nbsp;</div>\n\n<div>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-1-1\">[\"abcd\",\"cdab\",\"cbad\",\"xyzz\",\"zzxy\",\"zzyx\"]</span>\n<strong>Output: </strong><span id=\"example-output-1\">3</span>\n<strong>Explanation: </strong>\nOne group is [\"abcd\", \"cdab\", \"cbad\"], since they are all pairwise special equivalent, and none of the other strings are all pairwise special equivalent to these.\n\nThe other two groups are [\"xyzz\", \"zzxy\"] and [\"zzyx\"].  Note that in particular, \"zzxy\" is not special equivalent to \"zzyx\".\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-2-1\">[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"]</span>\n<strong>Output: </strong><span id=\"example-output-2\">3</span></pre>\n\n<p>&nbsp;</p>\n</div>\n</div>\n\n<div>\n<div>\n<div>\n<div>\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= A.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= A[i].length &lt;= 20</code></li>\n\t<li>All <code>A[i]</code> have the same length.</li>\n\t<li>All <code>A[i]</code> consist of only lowercase letters.</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong int calc_even(string a)\n{\n    long int product = 1;\n    int arr[26] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\n\n    int n = a.length();\n    for(int i = 0; i < n; i+=2) {\n        product *= arr[(int)(a[i]) - 97];\n    }\n\n    return product;\n}\n\nlong int calc_odd(string a)\n{\n    long int product = 1;\n    int arr[26] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\n\n    int n = a.length();\n    for(int i = 1; i < n; i+=2) {\n        product *= arr[(int)(a[i]) - 97];\n    }\n\n    return product;\n}\n\nclass Solution\n{\npublic:\n    int numSpecialEquivGroups(vector<string> &A)\n    {\n        vector<int> matches;\n        vector<int> even_scores;\n        vector<int> odd_scores;\n\n        for(string temp: A) {\n            even_scores.push_back(calc_even(temp));\n            odd_scores.push_back(calc_odd(temp));\n        }\n\n        int len = A.size();\n\n        for (int i = 0; i < len; i++)\n        {\n            matches.push_back(-1);\n            for (int j = i + 1; j < len; j++)\n            {\n                if (even_scores[i] == even_scores[j] && odd_scores[i] == odd_scores[j])\n                {\n                    matches[i] = j;\n                    j = len;\n                }\n            }\n        }\n\n        int *group_id = (int *)malloc(sizeof(int) * len);\n        fill_n(group_id, len, 0);\n\n        int group_number = 0;\n\n        for (int i = 0; i < len; i++)\n        {\n            if (!group_id[i])\n                group_id[i] = ++group_number;\n            if (matches[i] != -1)\n            {\n                group_id[matches[i]] = group_id[i];\n            }\n        }\n\n        return group_number;\n    }\n};"}