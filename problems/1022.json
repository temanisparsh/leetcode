{"link": "https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers", "name": "Sum of Root To Leaf Binary Numbers", "difficulty": "Easy", "statement": "<div><p>You are given the <code>root</code> of a binary tree where each node has a value <code>0</code>&nbsp;or <code>1</code>.&nbsp; Each root-to-leaf path represents a binary number starting with the most significant bit.&nbsp; For example, if the path is <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>, then this could represent <code>01101</code> in binary, which is <code>13</code>.</p>\n\n<p>For all leaves in the tree, consider the numbers represented by the path&nbsp;from the root to that leaf.</p>\n\n<p>Return <em>the sum of these numbers</em>. The answer is <strong>guaranteed</strong> to fit in a <strong>32-bits</strong> integer.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png\" style=\"width: 450px; height: 296px;\">\n<pre><strong>Input:</strong> root = [1,0,1,0,1,0,1]\n<strong>Output:</strong> 22\n<strong>Explanation: </strong>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> root = [0]\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><strong>Input:</strong> root = [1,1]\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\n\t<li><code>Node.val</code> is <code>0</code> or <code>1</code>.</li>\n</ul>\n</div>", "language": "c", "solution": "#include <stdio.h>\n\nstruct TreeNode\n{\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n\nint sumRootToLeaf(struct TreeNode *root)\n{\n    return findSum(root, 0);\n}\n\nint findSum(struct TreeNode *root, int prevSum) {\n\n    int sum = 0;\n\n    if (root->left)\n        sum += findSum(root->left, 2*prevSum + root->val);\n    if (root->right)\n        sum += findSum(root->right, 2*prevSum + root->val);\n\n    if (!root->left && !root->right)\n        return prevSum*2 + root->val;\n    return sum;\n\n}"}