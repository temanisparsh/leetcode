(this.webpackJsonpleetcode=this.webpackJsonpleetcode||[]).push([[0],{44:function(n,e,t){n.exports=t(524)},49:function(n,e,t){},50:function(n,e,t){},524:function(n,e,t){"use strict";t.r(e);var s=t(2),r=t.n(s),o=t(10),i=t.n(o),a=(t(49),t(12)),p=t(21),l=t.n(p),c=(t(50),t(51),t(526)),d=t(527),u=t(528),g=t(529),m=t(530),h=t(533),b=t(531),f=t(532),v=t(13),y=t(22),x=t(7),S=t(52),E=function(n){var e=n.updateProblem,t=Object(s.useState)("Easy"),o=Object(a.a)(t,2),i=o[0],p=o[1],h=Object(s.useState)([]),b=Object(a.a)(h,2),f=b[0],v=b[1];return Object(s.useEffect)((function(){v("All"!==i?l.a.filter(x,(function(n){return n.difficulty===i})):x)}),[i]),r.a.createElement("div",{className:"main"},r.a.createElement(c.a,null,r.a.createElement(d.a,{href:"./"},"Leetcode Solutions"),r.a.createElement(u.a,null,r.a.createElement("a",{href:"https://www.github.com/temanisparsh/leetcode",target:"_blank"},"Source Code"))),r.a.createElement("div",{className:"button-group"},r.a.createElement(g.a,{size:"lg"},r.a.createElement(m.a,{className:"btn btn-dark",color:"light",onClick:function(){return p("All")}},"All"),r.a.createElement(m.a,{className:"btn btn-dark",color:"light",onClick:function(){return p("Easy")}},"Easy"),r.a.createElement(m.a,{className:"btn btn-dark",color:"light",onClick:function(){return p("Medium")}},"Medium"),r.a.createElement(m.a,{className:"btn btn-dark",color:"light",onClick:function(){return p("Hard")}},"Hard"))),r.a.createElement("div",{className:"problems"},l.a.map(f,(function(n){return r.a.createElement("a",{onClick:function(){return e(n.number)},href:"#"+n.number,key:n.number,className:"problem-card"},n.number+".   "+n.name)}))),!f.length&&"All"!==i&&r.a.createElement("div",{className:"main-error"},"No Problems found in this section"))},_=function(n){var e=n.problem,t=n.updateProblem,o=Object(s.useState)(!!e),i=Object(a.a)(o,2),p=i[0],l=i[1],c=function(){l(!p),t(null)};return Object(s.useEffect)((function(){window.innerWidth<760&&e&&l(!0)}),[e]),r.a.createElement("div",{className:"problem"},!p&&e&&r.a.createElement("div",{className:"problem-desktop"},r.a.createElement("div",{className:"problem-statement"},r.a.createElement("h4",null,r.a.createElement("a",{href:x[e].link,target:"_blank"},x[e].number+".   "+x[e].name)),S(x[e].statement)),r.a.createElement(v.b,{code:"Solution in "+x[e].language+":\n\n"+x[e].solution,theme:y.a,disabled:!0,language:"cpp"},r.a.createElement(v.a,null))),!p&&!e&&r.a.createElement("div",{className:"problem-error"},r.a.createElement("div",null,"Select a problem to view the solution.")),window.innerWidth<760&&p&&e&&r.a.createElement("div",{className:"problem-modal"},r.a.createElement(h.a,{isOpen:p,toggle:c},r.a.createElement(b.a,{toggle:c},r.a.createElement("a",{className:"problem-statement-link",href:x[e].link,target:"_blank"},x[e].number+".   "+x[e].name)),r.a.createElement(f.a,null,r.a.createElement("div",{className:"problem-statement"},S(x[e].statement)),r.a.createElement(v.b,{code:x[e].solution,theme:y.a,disabled:!0,language:"cpp"},r.a.createElement(v.a,null))))))},w=function(){var n=Object(s.useState)(null),e=Object(a.a)(n,2),t=e[0],o=e[1];return Object(s.useEffect)((function(){var n=window.location.hash.substring(1);x[n]&&o(n)}),[window.location]),r.a.createElement("div",{className:"app"},r.a.createElement(E,{updateProblem:o}),r.a.createElement(_,{problem:t,updateProblem:o}))};Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));i.a.render(r.a.createElement(r.a.StrictMode,null,r.a.createElement(w,null)),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(n){n.unregister()})).catch((function(n){console.error(n.message)}))},7:function(n){n.exports=JSON.parse('{"278":{"link":"https://leetcode.com/problems/first-bad-version","name":"First Bad Version","difficulty":"Easy","statement":"<div><p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>\\n\\n<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>\\n\\n<p>You are given an API <code>bool isBadVersion(version)</code> which returns whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 5, bad = 4\\n<strong>Output:</strong> 4\\n<strong>Explanation:</strong>\\ncall isBadVersion(3) -&gt; false\\ncall isBadVersion(5)&nbsp;-&gt; true\\ncall isBadVersion(4)&nbsp;-&gt; true\\nThen 4 is the first bad version.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 1, bad = 1\\n<strong>Output:</strong> 1\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= bad &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n// The API isBadVersion is defined for you.\\nbool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n\\n        long int low = 1;\\n        long int high = n;\\n        long int mid;\\n        while(low <= high) {\\n            mid = (long int)((low + high) / 2);\\n            bool isBad = isBadVersion(mid);\\n            if (!isBad) {\\n                low = mid + 1;\\n            }\\n            else {\\n                if (!(isBadVersion(mid - 1)))\\n                        return mid;\\n                high = mid-1;\\n            }\\n        }\\n        return mid;\\n\\n    }\\n};\\n","number":"278"},"344":{"link":"https://leetcode.com/problems/reverse-string","name":"Reverse String","difficulty":"Easy","statement":"<div><p>Write a function that reverses a string. The input string is given as an array of characters <code>char[]</code>.</p>\\n\\n<p>Do not allocate extra space for another array, you must do this by <strong>modifying the input array&nbsp;<a href=\\"https://en.wikipedia.org/wiki/In-place_algorithm\\" target=\\"_blank\\">in-place</a></strong> with O(1) extra memory.</p>\\n\\n<p>You may assume all the characters consist of <a href=\\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\\" target=\\"_blank\\">printable ascii characters</a>.</p>\\n\\n<p>&nbsp;</p>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[\\"h\\",\\"e\\",\\"l\\",\\"l\\",\\"o\\"]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">[\\"o\\",\\"l\\",\\"l\\",\\"e\\",\\"h\\"]</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">[\\"H\\",\\"a\\",\\"n\\",\\"n\\",\\"a\\",\\"h\\"]</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">[\\"h\\",\\"a\\",\\"n\\",\\"n\\",\\"a\\",\\"H\\"]</span>\\n</pre>\\n</div>\\n</div>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    void reverseString(vector<char> &s)\\n    {\\n        int n = s.size();\\n        for(int i = 0; i < n / 2; i++) {\\n            int temp = s[i];\\n            s[i] = s[n - i - 1];\\n            s[n - i - 1] = temp;\\n        }\\n    }\\n};","number":"344"},"461":{"link":"https://leetcode.com/problems/hamming-distance","name":"Hamming Distance","difficulty":"Easy","statement":"<div><p>The <a href=\\"https://en.wikipedia.org/wiki/Hamming_distance\\" target=\\"_blank\\">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\\n\\n<p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p>\\n\\n<p><b>Note:</b><br>\\n0 \u2264 <code>x</code>, <code>y</code> &lt; 2<sup>31</sup>.\\n</p>\\n\\n<p><b>Example:</b>\\n</p><pre><b>Input:</b> x = 1, y = 4\\n\\n<b>Output:</b> 2\\n\\n<b>Explanation:</b>\\n1   (0 0 0 1)\\n4   (0 1 0 0)\\n       \u2191   \u2191\\n\\nThe above arrows point to positions where the corresponding bits are different.\\n</pre>\\n<p></p></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n\\n        int count  = 0;\\n        while (x || y) {\\n            if (x % 2 != y % 2) count ++;\\n            x /= 2; y/= 2;\\n        }\\n\\n        return count;\\n        \\n    }\\n};","number":"461"},"476":{"link":"https://leetcode.com/problems/number-complement","name":"Number Complement","difficulty":"Easy","statement":"<div><p>Given a <strong>positive</strong> integer <code>num</code>, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> num = 5\\n<strong>Output:</strong> 2\\n<strong>Explanation:</strong> The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> num = 1\\n<strong>Output:</strong> 0\\n<strong>Explanation:</strong> The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li>The given integer <code>num</code> is guaranteed to fit within the range of a 32-bit signed integer.</li>\\n\\t<li><code>num &gt;= 1</code></li>\\n\\t<li>You could assume no leading zero bit in the integer\u2019s binary representation.</li>\\n\\t<li>This question is the same as 1009:&nbsp;<a href=\\"https://leetcode.com/problems/complement-of-base-10-integer/\\">https://leetcode.com/problems/complement-of-base-10-integer/</a></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include<math.h>\\n\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        \\n        return pow(2, floor(log10(num)/log10(2)) + 1) - num - 1;\\n        \\n    }\\n};","number":"476"},"509":{"link":"https://leetcode.com/problems/fibonacci-number","name":"Fibonacci Number","difficulty":"Easy","statement":"<div><p>The&nbsp;<b>Fibonacci numbers</b>, commonly denoted&nbsp;<code>F(n)</code>&nbsp;form a sequence, called the&nbsp;<b>Fibonacci sequence</b>, such that each number is the sum of the two preceding ones, starting from <code>0</code> and <code>1</code>. That is,</p>\\n\\n<pre>F(0) = 0,&nbsp; &nbsp;F(1)&nbsp;= 1\\nF(N) = F(N - 1) + F(N - 2), for N &gt; 1.\\n</pre>\\n\\n<p>Given <code>N</code>, calculate <code>F(N)</code>.</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> 2\\n<strong>Output:</strong> 1\\n<strong>Explanation:</strong> F(2) = F(1) + F(0) = 1 + 0 = 1.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> 3\\n<strong>Output:</strong> 2\\n<strong>Explanation:</strong> F(3) = F(2) + F(1) = 1 + 1 = 2.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> 4\\n<strong>Output:</strong> 3\\n<strong>Explanation:</strong> F(4) = F(3) + F(2) = 2 + 1 = 3.\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<p>0 \u2264 <code>N</code> \u2264 30.</p>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int fib(int N)\\n    {\\n        int *arr = (int *)malloc(sizeof(int) * N + 1);\\n\\n        int n = N;\\n        if (n == 0) return 0;\\n        if (n == 1) return 1;\\n\\n        arr[0] = 0;\\n        arr[1] = 1;\\n\\n        for(int i = 2; i <= N; i++)\\n            arr[i] = arr[i-1] + arr[i-2];\\n\\n        return arr[N];\\n\\n    }\\n};","number":"509"},"557":{"link":"https://leetcode.com/problems/reverse-words-in-a-string-iii","name":"Reverse Words in a String III","difficulty":"Easy","statement":"<div><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>\\n\\n<p><b>Example 1:</b><br>\\n</p><pre><b>Input:</b> \\"Let\'s take LeetCode contest\\"\\n<b>Output:</b> \\"s\'teL ekat edoCteeL tsetnoc\\"\\n</pre>\\n<p></p>\\n\\n<p><b>Note:</b>\\nIn the string, each word is separated by single space and there will not be any extra space in the string.\\n</p></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    string reverseWords(string s) {\\n\\n        vector<int> ind;\\n        ind.push_back(-1);\\n        int n = s.length();\\n\\n        for(int i = 0; i < n; i++) {\\n            if (s[i] == \' \') {\\n                ind.push_back(i);\\n            }\\n        }\\n\\n        ind.push_back(n);\\n\\n        stringstream res;\\n\\n        int nums = ind.size();\\n        for(int i = 0; i < nums - 1; i++) {\\n            for(int j = ind[i + 1] - 1; j > ind[i]; j--) {\\n                res << s[j];\\n            }\\n            if (i < nums - 2) {\\n                res << \' \';\\n            }\\n        }\\n\\n        return res.str();\\n    }\\n};","number":"557"},"559":{"link":"https://leetcode.com/problems/maximum-depth-of-n-ary-tree","name":"Maximum Depth of N-ary Tree","difficulty":"Easy","statement":"<div><p>Given a n-ary tree, find its maximum depth.</p>\\n\\n<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\\n\\n<p><em>Nary-Tree input serialization&nbsp;is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<p><img src=\\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\\" style=\\"width: 100%; max-width: 300px;\\"></p>\\n\\n<pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\\n<strong>Output:</strong> 3\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\\" style=\\"width: 296px; height: 241px;\\"></p>\\n\\n<pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\\n<strong>Output:</strong> 5\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li>The depth of the n-ary tree is less than or equal to <code>1000</code>.</li>\\n\\t<li>The total number of nodes is between <code>[0,&nbsp;10^4]</code>.</li>\\n</ul>\\n</div>","language":"c","solution":"\\nstruct Node\\n{\\n    int val;\\n    int numChildren;\\n    struct Node **children;\\n};\\n\\nint *maxDepth(struct Node *root)\\n{\\n    return calc_depth(root, 0);\\n}\\n\\nint calc_depth(struct Node *root, int depth)\\n{\\n    if (!root)\\n        return depth;\\n    int old_depth = depth;\\n    depth += 1;\\n    for (int i = 0; i < root->numChildren; i++)\\n    {\\n        int newd = calc_depth(root->children[i], old_depth + 1);\\n        printf(\\"%d\\\\n\\", newd);\\n        depth = depth > newd ? depth : newd;\\n    }\\n    return depth;\\n}","number":"559"},"561":{"link":"https://leetcode.com/problems/array-partition-i","name":"Array Partition I","difficulty":"Easy","statement":"<div><p>\\nGiven an array of <b>2n</b> integers, your task is to group these integers into <b>n</b> pairs of integer, say (a<sub>1</sub>, b<sub>1</sub>), (a<sub>2</sub>, b<sub>2</sub>), ..., (a<sub>n</sub>, b<sub>n</sub>) which makes sum of min(a<sub>i</sub>, b<sub>i</sub>) for all i from 1 to n as large as possible.\\n</p>\\n\\n<p><b>Example 1:</b><br>\\n</p><pre><b>Input:</b> [1,4,3,2]\\n\\n<b>Output:</b> 4\\n<b>Explanation:</b> n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\\n</pre>\\n<p></p>\\n\\n<p><b>Note:</b><br>\\n</p><ol>\\n<li><b>n</b> is a positive integer, which is in the range of [1, 10000].</li>\\n<li>All the integers in the array will be in the range of [-10000, 10000].</li>\\n</ol>\\n<p></p></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n\\n       sort(nums.begin(), nums.end());\\n\\n       int n = nums.size();\\n       int res = 0;\\n       for(int i = 0; i < n; i += 2)\\n            res += nums[i];\\n        \\n        return res;\\n        \\n    }\\n};","number":"561"},"589":{"link":"https://leetcode.com/problems/n-ary-tree-preorder-traversal","name":"N-ary Tree Preorder Traversal","difficulty":"Easy","statement":"<div><p>Given an n-ary tree, return the <i>preorder</i> traversal of its nodes\' values.</p>\\n\\n<p><em>Nary-Tree input serialization&nbsp;is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Follow up:</strong></p>\\n\\n<p>Recursive solution is trivial, could you do it iteratively?</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<p><img src=\\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\\" style=\\"width: 100%; max-width: 300px;\\"></p>\\n\\n<pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\\n<strong>Output:</strong> [1,3,5,6,2,4]\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\\" style=\\"width: 296px; height: 241px;\\"></p>\\n\\n<pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\\n<strong>Output:</strong> [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\\n\\t<li>The total number of nodes is between <code>[0,&nbsp;10^4]</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> preorder(Node* root) {\\n\\n        vector<int> res;\\n        if (!root) {\\n            return res;\\n        }\\n\\n        reverse((root->children).begin(), (root->children).end());\\n\\n        res.push_back(root->val);\\n\\n        for (Node* node: root->children) {\\n            vector<int> temp = preorder(node);\\n            res.insert(res.begin() + 1, temp.begin(), temp.end());\\n        }\\n        return res;\\n    }\\n};","number":"589"},"590":{"link":"https://leetcode.com/problems/n-ary-tree-postorder-traversal","name":"N-ary Tree Postorder Traversal","difficulty":"Easy","statement":"<div><p>Given an n-ary tree, return the <i>postorder</i> traversal of its nodes\' values.</p>\\n\\n<p><em>Nary-Tree input serialization&nbsp;is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Follow up:</strong></p>\\n\\n<p>Recursive solution is trivial, could you do it iteratively?</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<p><img src=\\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\\" style=\\"width: 100%; max-width: 300px;\\"></p>\\n\\n<pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\\n<strong>Output:</strong> [5,6,3,2,4,1]\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<p><img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\\" style=\\"width: 296px; height: 241px;\\"></p>\\n\\n<pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\\n<strong>Output:</strong> [2,6,14,11,7,3,12,8,4,13,9,10,5,1]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\\n\\t<li>The total number of nodes is between <code>[0,&nbsp;10^4]</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Node {\\npublic:\\n    int val;\\n    vector<Node*> children;\\n\\n    Node() {}\\n\\n    Node(int _val) {\\n        val = _val;\\n    }\\n\\n    Node(int _val, vector<Node*> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> postorder(Node* root) {\\n\\n        vector<int> res;\\n        if (!root) {\\n            return res;\\n        }\\n\\n        reverse((root->children).begin(), (root->children).end());\\n\\n        for (Node* node: root->children) {\\n            vector<int> temp = postorder(node);\\n            res.insert(res.begin(), temp.begin(), temp.end());\\n        }\\n\\n        res.push_back(root->val);\\n        return res;\\n    }\\n};","number":"590"},"617":{"link":"https://leetcode.com/problems/merge-two-binary-trees","name":"Merge Two Binary Trees","difficulty":"Easy","statement":"<div><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>\\n\\n<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>\\n\\n<p><b>Example 1:</b></p>\\n\\n<pre><b>Input:</b> \\n\\tTree 1                     Tree 2                  \\n          1                         2                             \\n         / \\\\                       / \\\\                            \\n        3   2                     1   3                        \\n       /                           \\\\   \\\\                      \\n      5                             4   7                  \\n<b>Output:</b> \\nMerged tree:\\n\\t     3\\n\\t    / \\\\\\n\\t   4   5\\n\\t  / \\\\   \\\\ \\n\\t 5   4   7\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><b>Note:</b> The merging process must start from the root nodes of both trees.</p>\\n</div>","language":"c","solution":"#include<stdio.h>\\n#include <stdlib.h>  \\n\\nstruct TreeNode\\n{\\n    int val;\\n    struct TreeNode *left;\\n    struct TreeNode *right;\\n};\\n\\nstruct TreeNode *mergeTrees(struct TreeNode *t1, struct TreeNode *t2)\\n{\\n\\n    if (!t1) return t2;\\n    if (!t2) return t1;\\n\\n    t1->val = t1->val + t2->val;\\n\\n    if (t1->left && t2->left)\\n        t1->left = mergeTrees(t1->left, t2->left);\\n    else if (t1->left)\\n        t1->left = t1->left;\\n    else if (t2->left)\\n        t1->left = t2->left;\\n\\n    if (t1->right && t2->right)\\n        t1->right = mergeTrees(t1->right, t2->right);\\n    else if (t1->right)\\n        t1->right = t1->right;\\n    else if (t2->right)\\n        t1->right = t2->right;\\n\\n    return t1;\\n}","number":"617"},"657":{"link":"https://leetcode.com/problems/robot-return-to-origin","name":"Robot Return to Origin","difficulty":"Easy","statement":"<div><p>There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot <strong>ends up at (0, 0)</strong> after it completes its moves.</p>\\n\\n<p>The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false.</p>\\n\\n<p><strong>Note</strong>: The way that the robot is \\"facing\\" is irrelevant. \\"R\\" will always make the robot move to the right once, \\"L\\" will always make it move left, etc. Also, assume that the magnitude of the robot\'s movement is the same for each move.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> moves = \\"UD\\"\\n<strong>Output:</strong> true\\n<strong>Explanation</strong>: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> moves = \\"LL\\"\\n<strong>Output:</strong> false\\n<strong>Explanation</strong>: The robot moves left twice. It ends up two \\"moves\\" to the left of the origin. We return false because it is not at the origin at the end of its moves.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> moves = \\"RRDD\\"\\n<strong>Output:</strong> false\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> moves = \\"LDRRLRUULR\\"\\n<strong>Output:</strong> false\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= moves.length &lt;= 2 * 10<sup>4</sup></code></li>\\n\\t<li><code>moves</code> only contains the characters <code>\'U\'</code>, <code>\'D\'</code>, <code>\'L\'</code> and <code>\'R\'</code>.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    bool judgeCircle(string moves)\\n    {\\n\\n        return count(moves.begin(), moves.end(), \'U\') == count(moves.begin(), moves.end(), \'D\') && count(moves.begin(), moves.end(), \'L\') == count(moves.begin(), moves.end(), \'R\');\\n    }\\n};","number":"657"},"700":{"link":"https://leetcode.com/problems/search-in-a-binary-search-tree","name":"Search in a Binary Search Tree","difficulty":"Easy","statement":"<div><p>Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node\'s value equals the given value. Return the subtree rooted with that node. If such node doesn\'t exist, you should return NULL.</p>\\n\\n<p>For example,&nbsp;</p>\\n\\n<pre>Given the tree:\\n        4\\n       / \\\\\\n      2   7\\n     / \\\\\\n    1   3\\n\\nAnd the value to search: 2\\n</pre>\\n\\n<p>You should return this subtree:</p>\\n\\n<pre>      2     \\n     / \\\\   \\n    1   3\\n</pre>\\n\\n<p>In the example above, if we want to search the value <code>5</code>, since there is no node with value <code>5</code>, we should return <code>NULL</code>.</p>\\n\\n<p>Note that an empty tree is represented by <code>NULL</code>, therefore you would see the expected output (serialized tree format) as&nbsp;<code>[]</code>, not <code>null</code>.</p>\\n</div>","language":"c","solution":"#include <stdio.h>\\n#include <stdlib.h>\\n\\nstruct TreeNode\\n{\\n    int val;\\n    struct TreeNode *left;\\n    struct TreeNode *right;\\n};\\n\\nstruct TreeNode *searchBST(struct TreeNode *root, int val)\\n{\\n    if (!root)\\n        return NULL;\\n\\n    if (root->val == val)\\n        return root;\\n\\n    struct TreeNode *left = searchBST(root->left, val);\\n    if (left)\\n        return left;\\n\\n    struct TreeNode *right = searchBST(root->right, val);\\n    if (right)\\n        return right;\\n\\n    return NULL;\\n}","number":"700"},"709":{"link":"https://leetcode.com/problems/to-lower-case","name":"To Lower Case","difficulty":"Easy","statement":"<div><p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.</p>\\n\\n<p>&nbsp;</p>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">\\"Hello\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">\\"hello\\"</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">\\"here\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">\\"here\\"</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-3-1\\">\\"LOVELY\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-3\\">\\"lovely\\"</span>\\n</pre>\\n</div>\\n</div>\\n</div></div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    string toLowerCase(string str) {\\n\\n        transform(str.begin(), str.end(), str.begin(), ::tolower);\\n\\n        return str;\\n        \\n    }\\n};","number":"709"},"728":{"link":"https://leetcode.com/problems/self-dividing-numbers","name":"Self Dividing Numbers","difficulty":"Easy","statement":"<div><p>\\nA <i>self-dividing number</i> is a number that is divisible by every digit it contains.\\n</p><p>\\nFor example, 128 is a self-dividing number because <code>128 % 1 == 0</code>, <code>128 % 2 == 0</code>, and <code>128 % 8 == 0</code>.\\n</p><p>\\nAlso, a self-dividing number is not allowed to contain the digit zero.\\n</p><p>\\nGiven a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.\\n</p>\\n<p><b>Example 1:</b><br>\\n</p><pre><b>Input:</b> \\nleft = 1, right = 22\\n<b>Output:</b> [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\\n</pre>\\n<p></p>\\n\\n<p><b>Note:</b>\\n</p><li>The boundaries of each input argument are <code>1 &lt;= left &lt;= right &lt;= 10000</code>.</li>\\n<p></p></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> selfDividingNumbers(int left, int right) {\\n\\n        vector<int> res;\\n        for(int i = left; i <= right; i++) {\\n\\n            int isValid = 1;\\n            int num = i;\\n            while (num) {\\n                int rem = num % 10;\\n                if (rem == 0 || i % rem != 0) isValid = 0;\\n                num /= 10;\\n            }\\n\\n            if (isValid) res.push_back(i);\\n\\n        }\\n\\n        return res;\\n        \\n    }\\n};","number":"728"},"771":{"link":"https://leetcode.com/problems/jewels-and-stones","name":"Jewels and Stones","difficulty":"Easy","statement":"<div><p>You\'re given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have.&nbsp; Each character in <code>S</code> is a type of stone you have.&nbsp; You want to know how many of the stones you have are also jewels.</p>\\n\\n<p>The letters in <code>J</code> are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so <code>\\"a\\"</code> is considered a different type of stone from <code>\\"A\\"</code>.</p>\\n\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> J = \\"aA\\", S = \\"aAAbbbb\\"\\n<strong>Output:</strong> 3\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> J = \\"z\\", S = \\"ZZ\\"\\n<strong>Output:</strong> 0\\n</pre>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ul>\\n\\t<li><code>S</code> and <code>J</code> will consist of letters and have length at most 50.</li>\\n\\t<li>The characters in <code>J</code> are distinct.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int numJewelsInStones(string J, string S)\\n    {\\n\\n        int isJewel[126];\\n\\n        fill_n(isJewel, 126, 0);\\n\\n        for (char i : J)\\n        {\\n            isJewel[(int)i] = 1;\\n        }\\n\\n        int count = 0;\\n        for (char i : S)\\n        {\\n            count += isJewel[(int)i];\\n        }\\n\\n        return count;\\n    }\\n};","number":"771"},"804":{"link":"https://leetcode.com/problems/unique-morse-code-words","name":"Unique Morse Code Words","difficulty":"Easy","statement":"<div><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>\\"a\\"</code> maps to <code>\\".-\\"</code>, <code>\\"b\\"</code> maps to <code>\\"-...\\"</code>, <code>\\"c\\"</code> maps to <code>\\"-.-.\\"</code>, and so on.</p>\\n\\n<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>\\n\\n<pre>[\\".-\\",\\"-...\\",\\"-.-.\\",\\"-..\\",\\".\\",\\"..-.\\",\\"--.\\",\\"....\\",\\"..\\",\\".---\\",\\"-.-\\",\\".-..\\",\\"--\\",\\"-.\\",\\"---\\",\\".--.\\",\\"--.-\\",\\".-.\\",\\"...\\",\\"-\\",\\"..-\\",\\"...-\\",\\".--\\",\\"-..-\\",\\"-.--\\",\\"--..\\"]</pre>\\n\\n<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \\"cab\\" can be written as \\"-.-..--...\\", (which is the concatenation \\"-.-.\\" + \\".-\\" + \\"<code>-...</code>\\"). We\'ll call such a concatenation, the transformation&nbsp;of a word.</p>\\n\\n<p>Return the number of different transformations among all words we have.</p>\\n\\n<pre><strong>Example:</strong>\\n<strong>Input:</strong> words = [\\"gin\\", \\"zen\\", \\"gig\\", \\"msg\\"]\\n<strong>Output:</strong> 2\\n<strong>Explanation: </strong>\\nThe transformation of each word is:\\n\\"gin\\" -&gt; \\"--...-.\\"\\n\\"zen\\" -&gt; \\"--...-.\\"\\n\\"gig\\" -&gt; \\"--...--.\\"\\n\\"msg\\" -&gt; \\"--...--.\\"\\n\\nThere are 2 different transformations, \\"--...-.\\" and \\"--...--.\\".\\n</pre>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ul>\\n\\t<li>The length of <code>words</code> will be at most <code>100</code>.</li>\\n\\t<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>\\n\\t<li><code>words[i]</code> will only consist of lowercase letters.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int uniqueMorseRepresentations(vector<string> &words)\\n    {\\n\\n        vector<string> codes;\\n        int n = words.size();\\n\\n        string mapping[26] = {\\".-\\", \\"-...\\", \\"-.-.\\", \\"-..\\", \\".\\", \\"..-.\\", \\"--.\\", \\"....\\", \\"..\\", \\".---\\", \\"-.-\\", \\".-..\\", \\"--\\", \\"-.\\", \\"---\\", \\".--.\\", \\"--.-\\", \\".-.\\", \\"...\\", \\"-\\", \\"..-\\", \\"...-\\", \\".--\\", \\"-..-\\", \\"-.--\\", \\"--..\\"};\\n\\n        for (string word : words)\\n        {\\n\\n            stringstream r;\\n\\n            for (char c : word)\\n            {\\n                r << mapping[(int)(c)-97];\\n            }\\n\\n            string res = r.str();\\n            codes.push_back(res);\\n        }\\n\\n        sort(codes.begin(), codes.end());\\n\\n        int count = n > 0 ? 1 : 0;\\n\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (codes[i].compare(codes[i - 1]))\\n                ++count;\\n        }\\n\\n        return count;\\n    }\\n};","number":"804"},"811":{"link":"https://leetcode.com/problems/subdomain-visit-count","name":"Subdomain Visit Count","difficulty":"Easy","statement":"<div><p>A website domain like \\"discuss.leetcode.com\\" consists of various subdomains. At the top level, we have \\"com\\", at the next level, we have \\"leetcode.com\\", and at the lowest level, \\"discuss.leetcode.com\\". When we visit a domain like \\"discuss.leetcode.com\\", we will also visit the parent domains \\"leetcode.com\\" and \\"com\\" implicitly.</p>\\n\\n<p>Now, call a \\"count-paired domain\\" to be a count (representing the number of visits this domain received), followed by a space, followed by the address. An example of a count-paired domain might be \\"9001 discuss.leetcode.com\\".</p>\\n\\n<p>We are given a list <code>cpdomains</code> of count-paired domains. We would like a list of count-paired domains, (in the same format as the input, and in any order), that explicitly counts the number of visits to each subdomain.</p>\\n\\n<pre><strong>Example 1:</strong>\\n<strong>Input:</strong> \\n[\\"9001 discuss.leetcode.com\\"]\\n<strong>Output:</strong> \\n[\\"9001 discuss.leetcode.com\\", \\"9001 leetcode.com\\", \\"9001 com\\"]\\n<strong>Explanation:</strong> \\nWe only have one website domain: \\"discuss.leetcode.com\\". As discussed above, the subdomain \\"leetcode.com\\" and \\"com\\" will also be visited. So they will all be visited 9001 times.\\n\\n</pre>\\n\\n<pre><strong>Example 2:</strong>\\n<strong>Input:</strong> \\n[\\"900 google.mail.com\\", \\"50 yahoo.com\\", \\"1 intel.mail.com\\", \\"5 wiki.org\\"]\\n<strong>Output:</strong> \\n[\\"901 mail.com\\",\\"50 yahoo.com\\",\\"900 google.mail.com\\",\\"5 wiki.org\\",\\"5 org\\",\\"1 intel.mail.com\\",\\"951 com\\"]\\n<strong>Explanation:</strong> \\nWe will visit \\"google.mail.com\\" 900 times, \\"yahoo.com\\" 50 times, \\"intel.mail.com\\" once and \\"wiki.org\\" 5 times. For the subdomains, we will visit \\"mail.com\\" 900 + 1 = 901 times, \\"com\\" 900 + 50 + 1 = 951 times, and \\"org\\" 5 times.\\n\\n</pre>\\n\\n<p><strong>Notes: </strong></p>\\n\\n<ul>\\n\\t<li>The length of <code>cpdomains</code> will not exceed&nbsp;<code>100</code>.&nbsp;</li>\\n\\t<li>The length of each domain name will not exceed <code>100</code>.</li>\\n\\t<li>Each address will have either 1 or 2 \\".\\" characters.</li>\\n\\t<li>The input count&nbsp;in any count-paired domain will not exceed <code>10000</code>.</li>\\n\\t<li>The answer output can be returned in any order.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<string> subdomainVisits(vector<string>& cpdomains) {\\n\\n        vector<string> res;\\n\\n        unordered_map<string, int> count;\\n        for (string x: cpdomains) {\\n\\n            int space_pos = x.find(\' \');\\n            string num_string = x.substr(0, space_pos);\\n            int num = stoi(num_string);\\n            string domain = x.substr(space_pos + 1);\\n\\n            if (count[domain]) count[domain] += num;\\n            else count[domain] = num;\\n\\n            for (int i = 0; i < domain.length(); i++) {\\n                if (domain[i] == \'.\') {\\n                    if (count[domain.substr(i+1)]) count[domain.substr(i+1)] += num;\\n                    else count[domain.substr(i+1)] = num;\\n                }\\n            }\\n\\n        }\\n        for (auto x: count) {\\n            stringstream r;\\n            r << x.second << \\" \\" << x.first;\\n            res.push_back(r.str());\\n        }\\n        return res;\\n    }\\n};","number":"811"},"821":{"link":"https://leetcode.com/problems/shortest-distance-to-a-character","name":"Shortest Distance to a Character","difficulty":"Easy","statement":"<div><p>Given a string <code>S</code>&nbsp;and a character <code>C</code>, return an array of integers representing the shortest distance from the character <code>C</code> in the string.</p>\\n\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> S = \\"loveleetcode\\", C = \'e\'\\n<strong>Output:</strong> [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ol>\\n\\t<li><code>S</code> string length is&nbsp;in&nbsp;<code>[1, 10000].</code></li>\\n\\t<li><code>C</code>&nbsp;is a single character, and guaranteed to be in string <code>S</code>.</li>\\n\\t<li>All letters in <code>S</code> and <code>C</code> are lowercase.</li>\\n</ol>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> shortestToChar(string S, char C)\\n    {\\n        vector<int> poss;\\n        int n = S.length();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (S[i] == C)\\n            {\\n                poss.push_back(i);\\n            }\\n        }\\n\\n        vector<int> out;\\n\\n        int occ = poss.size();\\n\\n        if (occ)\\n        {\\n            for (int i = 0; i <= poss[0]; ++i)\\n                out.push_back(poss[0] - i);\\n        }\\n        for (int i = 0; i < occ - 1; i++)\\n        {\\n            for (int j = poss[i] + 1; j <= poss[i + 1]; ++j)\\n            {\\n                out.push_back(min((j - poss[i]), (poss[i + 1] - j)));\\n            }\\n        }\\n\\n        if (occ)\\n        {\\n            for (int i = poss[occ - 1] + 1; i < n; ++i)\\n                out.push_back(i - poss[occ - 1]);\\n        }\\n\\n        return out;\\n    }\\n};","number":"821"},"832":{"link":"https://leetcode.com/problems/flipping-an-image","name":"Flipping an Image","difficulty":"Easy","statement":"<div><p>Given a binary matrix <code>A</code>, we want to flip the image horizontally, then invert it, and return the resulting image.</p>\\n\\n<p>To flip an image horizontally means that each row of the image is reversed.&nbsp; For example, flipping&nbsp;<code>[1, 1, 0]</code>&nbsp;horizontally results in&nbsp;<code>[0, 1, 1]</code>.</p>\\n\\n<p>To invert an image means&nbsp;that each <code>0</code> is replaced by <code>1</code>, and each <code>1</code> is replaced by <code>0</code>.&nbsp;For example, inverting&nbsp;<code>[0, 1, 1]</code>&nbsp;results in&nbsp;<code>[1, 0, 0]</code>.</p>\\n\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong>[[1,1,0],[1,0,1],[0,0,0]]\\n<strong>Output: </strong>[[1,0,0],[0,1,0],[1,1,1]]\\n<strong>Explanation:</strong> First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\\nThen, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong>[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\\n<strong>Output: </strong>[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\\n<strong>Explanation:</strong> First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\\nThen invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\\n</pre>\\n\\n<p><strong>Notes:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>\\n\\t<li><code>0 &lt;= A[i][j]<font face=\\"sans-serif, Arial, Verdana, Trebuchet MS\\">&nbsp;&lt;=&nbsp;</font>1</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\\n\\n        int n = A.size();\\n\\n        vector<vector<int>> res;\\n\\n        for (vector<int> a: A) {\\n            vector<int> temp;\\n            for(int x: a) {\\n                temp.push_back(1-x);\\n            }\\n            reverse(temp.begin(), temp.end());\\n            res.push_back(temp);\\n        }\\n\\n        return res;\\n        \\n    }\\n};","number":"832"},"852":{"link":"https://leetcode.com/problems/peak-index-in-a-mountain-array","name":"Peak Index in a Mountain Array","difficulty":"Easy","statement":"<div><p>Let\'s call an array <code>arr</code> a <strong>mountain</strong>&nbsp;if the following properties hold:</p>\\n\\n<ul>\\n\\t<li><code>arr.length &gt;= 3</code></li>\\n\\t<li>There exists some <code>i</code> with&nbsp;<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>&nbsp;such that:\\n\\t<ul>\\n\\t\\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\\n\\t\\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\\n\\t</ul>\\n\\t</li>\\n</ul>\\n\\n<p>Given an integer array arr that is <strong>guaranteed</strong> to be&nbsp;a mountain, return any&nbsp;<code>i</code>&nbsp;such that&nbsp;<code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n<pre><strong>Input:</strong> arr = [0,1,0]\\n<strong>Output:</strong> 1\\n</pre><p><strong>Example 2:</strong></p>\\n<pre><strong>Input:</strong> arr = [0,2,1,0]\\n<strong>Output:</strong> 1\\n</pre><p><strong>Example 3:</strong></p>\\n<pre><strong>Input:</strong> arr = [0,10,5,2]\\n<strong>Output:</strong> 1\\n</pre><p><strong>Example 4:</strong></p>\\n<pre><strong>Input:</strong> arr = [3,4,5,1]\\n<strong>Output:</strong> 2\\n</pre><p><strong>Example 5:</strong></p>\\n<pre><strong>Input:</strong> arr = [24,69,100,99,79,78,67,36,26,19]\\n<strong>Output:</strong> 2\\n</pre>\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>3 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\\n\\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>\\n\\t<li><code>arr</code> is <strong>guaranteed</strong> to be a mountain array.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int peakIndexInMountainArray(vector<int>& A) {\\n\\n        int n = A.size();\\n        for (int i = 1; i < n-1; i++) {\\n            if (A[i] > A[i-1] && A[i] > A[i+1]) return i;\\n        }\\n        return  -1;\\n    }\\n};","number":"852"},"876":{"link":"https://leetcode.com/problems/middle-of-the-linked-list","name":"Middle of the Linked List","difficulty":"Easy","statement":"<div><p>Given a non-empty, singly&nbsp;linked list with head node <code>head</code>, return&nbsp;a&nbsp;middle node of linked list.</p>\\n\\n<p>If there are two middle nodes, return the second middle node.</p>\\n\\n<p>&nbsp;</p>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[1,2,3,4,5]</span>\\n<strong>Output: </strong>Node 3 from this list (Serialization: <span id=\\"example-output-1\\">[3,4,5]</span>)\\nThe returned node has value 3.  (The judge\'s serialization of this node is [3,4,5]).\\nNote that we returned a ListNode object ans, such that:\\nans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">[1,2,3,4,5,6]</span>\\n<strong>Output: </strong>Node 4 from this list (Serialization: <span id=\\"example-output-2\\">[4,5,6]</span>)\\nSince the list has two middle nodes with values 3 and 4, we return the second one.\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ul>\\n\\t<li>The number of nodes in the given list will be between <code>1</code>&nbsp;and <code>100</code>.</li>\\n</ul>\\n</div>\\n</div>\\n</div>","language":"C","solution":"\\nstruct ListNode\\n{\\n    int val;\\n    struct ListNode *next;\\n};\\n\\nstruct ListNode *middleNode(struct ListNode *head)\\n{\\n    int n = 0;\\n    struct ListNode* curr = head;\\n\\n    while(curr) {\\n        curr = curr->next;\\n        ++n;\\n    }\\n    curr = head;\\n    for(int i = 0;  i < n/2; ++i)\\n        curr = curr->next;\\n    return curr;\\n}","number":"876"},"883":{"link":"https://leetcode.com/problems/projection-area-of-3d-shapes","name":"Projection Area of 3D Shapes","difficulty":"Easy","statement":"<div><p>On a&nbsp;<code>N&nbsp;*&nbsp;N</code> grid, we place some&nbsp;<code>1 * 1 * 1&nbsp;</code>cubes that are axis-aligned with the x, y, and z axes.</p>\\n\\n<p>Each value&nbsp;<code>v = grid[i][j]</code>&nbsp;represents a tower of&nbsp;<code>v</code>&nbsp;cubes placed on top of grid cell <code>(i, j)</code>.</p>\\n\\n<p>Now we view the&nbsp;<em>projection</em>&nbsp;of these cubes&nbsp;onto the xy, yz, and zx planes.</p>\\n\\n<p>A projection is like a shadow, that&nbsp;maps our 3 dimensional figure to a 2 dimensional plane.&nbsp;</p>\\n\\n<p>Here, we are viewing the \\"shadow\\" when looking at the cubes from the top, the front, and the side.</p>\\n\\n<p>Return the total area of all three projections.</p>\\n\\n<p>&nbsp;</p>\\n\\n<div>\\n<ul>\\n</ul>\\n</div>\\n\\n<div>\\n<div>\\n<ul>\\n</ul>\\n</div>\\n</div>\\n\\n<div>\\n<div>\\n<div>\\n<div>\\n<ul>\\n</ul>\\n</div>\\n</div>\\n</div>\\n</div>\\n\\n<div>\\n<div>\\n<div>\\n<div>\\n<div>\\n<div>\\n<div>\\n<div>\\n<ul>\\n</ul>\\n</div>\\n</div>\\n</div>\\n</div>\\n</div>\\n</div>\\n</div>\\n</div>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[[2]]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">5</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">[[1,2],[3,4]]</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">17</span>\\n<strong>Explanation: </strong>\\nHere are the three projections (\\"shadows\\") of the shape made with each axis-aligned plane.\\n<img alt=\\"\\" src=\\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png\\" style=\\"width: 749px; height: 200px;\\">\\n</pre>\\n\\n<div>\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-3-1\\">[[1,0],[0,2]]</span>\\n<strong>Output: </strong><span id=\\"example-output-3\\">8</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-4-1\\">[[1,1,1],[1,0,1],[1,1,1]]</span>\\n<strong>Output: </strong><span id=\\"example-output-4\\">14</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 5:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-5-1\\">[[2,2,2],[2,1,2],[2,2,2]]</span>\\n<strong>Output: </strong><span id=\\"example-output-5\\">21</span>\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<div>\\n<div>\\n<div>\\n<p><span><strong>Note:</strong></span></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= grid.length = grid[0].length&nbsp;&lt;= 50</code></li>\\n\\t<li><code>0 &lt;= grid[i][j] &lt;= 50</code></li>\\n</ul>\\n</div>\\n</div>\\n</div>\\n</div>\\n</div>\\n</div>\\n</div>\\n</div>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int projectionArea(vector<vector<int>> &grid)\\n    {\\n        int n = grid.size();\\n\\n        int top = 0;\\n        for (vector<int> temp : grid)\\n        {\\n            for (int i : temp)\\n            {\\n                if (i)\\n                    ++top;\\n            }\\n        }\\n\\n        vector<int> front;\\n        vector<int> right;\\n        for (int i = 0; i < n; i++)\\n        {\\n            front.push_back(0);\\n            right.push_back(0);\\n            for (int j = 0; j < n; j++)\\n            {\\n                front[i] = max(front[i], grid[i][j]);\\n                right[i] = max(right[i], grid[j][i]);\\n            }\\n        }\\n\\n        return top + accumulate(front.begin(), front.end(), 0) + accumulate(right.begin(), right.end(), 0);\\n    }\\n};","number":"883"},"893":{"link":"https://leetcode.com/problems/groups-of-special-equivalent-strings","name":"Groups of Special-Equivalent Strings","difficulty":"Easy","statement":"<div><p>You are given an array <code>A</code> of strings.</p>\\n\\n<p>A <em>move&nbsp;onto <code>S</code></em> consists of swapping any two even indexed characters of <code>S</code>, or any two odd indexed characters of <code>S</code>.</p>\\n\\n<p>Two strings <code>S</code> and <code>T</code> are&nbsp;<em>special-equivalent</em>&nbsp;if after any number of <em>moves onto <code>S</code></em>, <code>S == T</code>.</p>\\n\\n<p>For example, <code>S = \\"zzxy\\"</code> and <code>T = \\"xyzz\\"</code> are special-equivalent because we may make the moves <code>\\"zzxy\\" -&gt; \\"xzzy\\" -&gt; \\"xyzz\\"</code>&nbsp;that swap <code>S[0]</code> and <code>S[2]</code>, then <code>S[1]</code> and <code>S[3]</code>.</p>\\n\\n<p>Now, a <em>group of special-equivalent strings from <code>A</code></em>&nbsp;is a non-empty subset of&nbsp;A such that:</p>\\n\\n<ol>\\n\\t<li>Every pair of strings in the group are special equivalent, and;</li>\\n\\t<li>The group is the largest size possible (ie., there isn\'t a string S not in the group such that S is special equivalent to every string in the group)</li>\\n</ol>\\n\\n<p>Return the number of groups of special-equivalent strings from <code>A</code>.</p>\\n\\n<div>&nbsp;</div>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[\\"abcd\\",\\"cdab\\",\\"cbad\\",\\"xyzz\\",\\"zzxy\\",\\"zzyx\\"]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">3</span>\\n<strong>Explanation: </strong>\\nOne group is [\\"abcd\\", \\"cdab\\", \\"cbad\\"], since they are all pairwise special equivalent, and none of the other strings are all pairwise special equivalent to these.\\n\\nThe other two groups are [\\"xyzz\\", \\"zzxy\\"] and [\\"zzyx\\"].  Note that in particular, \\"zzxy\\" is not special equivalent to \\"zzyx\\".\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">[\\"abc\\",\\"acb\\",\\"bac\\",\\"bca\\",\\"cab\\",\\"cba\\"]</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">3</span></pre>\\n\\n<p>&nbsp;</p>\\n</div>\\n</div>\\n\\n<div>\\n<div>\\n<div>\\n<div>\\n<p><strong>Note:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= A.length &lt;= 1000</code></li>\\n\\t<li><code>1 &lt;= A[i].length &lt;= 20</code></li>\\n\\t<li>All <code>A[i]</code> have the same length.</li>\\n\\t<li>All <code>A[i]</code> consist of only lowercase letters.</li>\\n</ul>\\n</div>\\n</div>\\n</div>\\n</div>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nlong int calc_even(string a)\\n{\\n    long int product = 1;\\n    int arr[26] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\\n\\n    int n = a.length();\\n    for(int i = 0; i < n; i+=2) {\\n        product *= arr[(int)(a[i]) - 97];\\n    }\\n\\n    return product;\\n}\\n\\nlong int calc_odd(string a)\\n{\\n    long int product = 1;\\n    int arr[26] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101};\\n\\n    int n = a.length();\\n    for(int i = 1; i < n; i+=2) {\\n        product *= arr[(int)(a[i]) - 97];\\n    }\\n\\n    return product;\\n}\\n\\nclass Solution\\n{\\npublic:\\n    int numSpecialEquivGroups(vector<string> &A)\\n    {\\n        vector<int> matches;\\n        vector<int> even_scores;\\n        vector<int> odd_scores;\\n\\n        for(string temp: A) {\\n            even_scores.push_back(calc_even(temp));\\n            odd_scores.push_back(calc_odd(temp));\\n        }\\n\\n        int len = A.size();\\n\\n        for (int i = 0; i < len; i++)\\n        {\\n            matches.push_back(-1);\\n            for (int j = i + 1; j < len; j++)\\n            {\\n                if (even_scores[i] == even_scores[j] && odd_scores[i] == odd_scores[j])\\n                {\\n                    matches[i] = j;\\n                    j = len;\\n                }\\n            }\\n        }\\n\\n        int *group_id = (int *)malloc(sizeof(int) * len);\\n        fill_n(group_id, len, 0);\\n\\n        int group_number = 0;\\n\\n        for (int i = 0; i < len; i++)\\n        {\\n            if (!group_id[i])\\n                group_id[i] = ++group_number;\\n            if (matches[i] != -1)\\n            {\\n                group_id[matches[i]] = group_id[i];\\n            }\\n        }\\n\\n        return group_number;\\n    }\\n};","number":"893"},"897":{"link":"https://leetcode.com/problems/increasing-order-search-tree","name":"Increasing Order Search Tree","difficulty":"Easy","statement":"<div><p>Given a binary search tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>\\n\\n<pre><strong>Example 1:</strong>\\n<strong>Input:</strong> [5,3,6,2,4,null,8,1,null,null,null,7,9]\\n\\n       5\\n      / \\\\\\n    3    6\\n   / \\\\    \\\\\\n  2   4    8\\n&nbsp;/        / \\\\ \\n1        7   9\\n\\n<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\\n\\n 1\\n&nbsp; \\\\\\n&nbsp;  2\\n&nbsp;   \\\\\\n&nbsp;    3\\n&nbsp;     \\\\\\n&nbsp;      4\\n&nbsp;       \\\\\\n&nbsp;        5\\n&nbsp;         \\\\\\n&nbsp;          6\\n&nbsp;           \\\\\\n&nbsp;            7\\n&nbsp;             \\\\\\n&nbsp;              8\\n&nbsp;               \\\\\\n                 9  </pre>\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li>The number of nodes in the given tree will be between <code>1</code> and <code>100</code>.</li>\\n\\t<li>Each node will have a unique integer value from <code>0</code> to <code>1000</code>.</li>\\n</ul>\\n</div>","language":"c","solution":"#include<stdio.h>\\n\\nstruct TreeNode\\n{\\n    int val;\\n    struct TreeNode *left;\\n    struct TreeNode *right;\\n};\\n\\nstruct TreeNode *increasingBST(struct TreeNode *root)\\n{\\n    struct TreeNode *middle = (struct TreeNode *)malloc(sizeof(struct TreeNode));\\n    middle->right = NULL;\\n    middle->left = NULL;\\n    middle->val = root->val;\\n\\n    struct TreeNode *left;\\n\\n    if (root->left)\\n    {\\n        left = increasingBST(root->left);\\n        struct TreeNode *temp = left;\\n        while (temp->right)\\n        {\\n            temp = temp->right;\\n        }\\n        temp->right = middle;\\n    }\\n\\n    if (root->right)\\n    {\\n        middle->right = increasingBST(root->right);\\n    }\\n    return root->left ? left : middle;\\n}","number":"897"},"905":{"link":"https://leetcode.com/problems/sort-array-by-parity","name":"Sort Array By Parity","difficulty":"Easy","statement":"<div><p>Given an array <code>A</code> of non-negative integers, return an array consisting of all the even elements of <code>A</code>, followed by all the odd elements of <code>A</code>.</p>\\n\\n<p>You may return any answer array that satisfies this condition.</p>\\n\\n<p>&nbsp;</p>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[3,1,2,4]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">[2,4,3,1]</span>\\nThe outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ol>\\n\\t<li><code>1 &lt;= A.length &lt;= 5000</code></li>\\n\\t<li><code>0 &lt;= A[i] &lt;= 5000</code></li>\\n</ol>\\n</div>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParity(vector<int>& A) {\\n\\n        vector<int> even;\\n        vector<int> odd;\\n        for(int i: A) if (i%2) odd.push_back(i); else even.push_back(i);\\n        for(int i: odd) even.push_back(i);\\n        return even;\\n\\n    }\\n};","number":"905"},"922":{"link":"https://leetcode.com/problems/sort-array-by-parity-ii","name":"Sort Array By Parity II","difficulty":"Easy","statement":"<div><p>Given an array <code>A</code>&nbsp;of non-negative integers, half of the integers in A are odd, and half of the integers are even.</p>\\n\\n<p>Sort the array so that whenever <code>A[i]</code> is odd, <code>i</code> is odd; and whenever <code>A[i]</code> is even, <code>i</code> is even.</p>\\n\\n<p>You may return any answer array that satisfies this condition.</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[4,2,5,7]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">[4,5,2,7]</span>\\n<strong>Explanation: </strong>[4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ol>\\n\\t<li><code>2 &lt;= A.length &lt;= 20000</code></li>\\n\\t<li><code>A.length % 2 == 0</code></li>\\n\\t<li><code>0 &lt;= A[i] &lt;= 1000</code></li>\\n</ol>\\n\\n<div>\\n<p>&nbsp;</p>\\n</div></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n\\n        vector<int> odd;\\n        vector<int> even;\\n\\n        vector<int> res;\\n\\n        for (int i: A) {\\n            if (i % 2) odd.push_back(i);\\n            else even.push_back(i);\\n        }\\n\\n        int even_len = even.size();\\n        int odd_len = odd.size();\\n\\n        for (int i = 0; i < odd_len; ++i) {\\n            res.push_back(even[i]);\\n            res.push_back(odd[i]);\\n        }\\n\\n        if (even_len > odd_len) \\n            res.push_back(even[even_len - 1]);\\n\\n        return res;\\n        \\n    }\\n};","number":"922"},"929":{"link":"https://leetcode.com/problems/unique-email-addresses","name":"Unique Email Addresses","difficulty":"Easy","statement":"<div><p>Every email consists of a local name and a domain name, separated by the @ sign.</p>\\n\\n<p>For example, in <code>alice@leetcode.com</code>,&nbsp;<code>alice</code> is the local name, and <code>leetcode.com</code> is the domain name.</p>\\n\\n<p>Besides lowercase letters, these emails may contain <code>\'.\'</code>s or <code>\'+\'</code>s.</p>\\n\\n<p>If you add periods (<code>\'.\'</code>) between some characters in the <strong>local name</strong> part of an email address, mail sent there will be forwarded to the same address without dots in the local name.&nbsp; For example, <code>\\"alice.z@leetcode.com\\"</code> and <code>\\"alicez@leetcode.com\\"</code> forward to the same email address.&nbsp; (Note that this rule does not apply for domain names.)</p>\\n\\n<p>If you add a plus (<code>\'+\'</code>) in the <strong>local name</strong>, everything after the first plus sign will be&nbsp;<strong>ignored</strong>. This allows certain emails to be filtered, for example&nbsp;<code>m.y+name@email.com</code>&nbsp;will be forwarded to&nbsp;<code>my@email.com</code>.&nbsp; (Again, this rule does not apply for domain names.)</p>\\n\\n<p>It is possible to use both of these rules at the same time.</p>\\n\\n<p>Given a list of <code>emails</code>, we send one email to each address in the list.&nbsp;&nbsp;How many different addresses actually receive mails?&nbsp;</p>\\n\\n<p>&nbsp;</p>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[\\"test.email+alex@leetcode.com\\",\\"test.e.mail+bob.cathy@leetcode.com\\",\\"testemail+david@lee.tcode.com\\"]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">2</span>\\n<strong><span>Explanation:</span></strong><span>&nbsp;\\"</span><span id=\\"example-input-1-1\\">testemail@leetcode.com\\" and \\"testemail@lee.tcode.com\\" </span>actually receive mails\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= emails[i].length&nbsp;&lt;= 100</code></li>\\n\\t<li><code>1 &lt;= emails.length &lt;= 100</code></li>\\n\\t<li>Each <code>emails[i]</code> contains exactly one <code>\'@\'</code> character.</li>\\n\\t<li>All local and domain names are non-empty.</li>\\n\\t<li>Local names do not start with a <code>\'+\'</code> character.</li>\\n</ul>\\n</div>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int numUniqueEmails(vector<string> &emails)\\n    {\\n\\n        set<string> track;\\n        for (string email : emails)\\n        {\\n            stringstream processed;\\n            int plusenc = 0;\\n            int atenc = 0;\\n            for(char ch: email) {\\n                if (ch == \'.\' && !atenc) continue;\\n                if (ch == \'+\') plusenc = 1;\\n                if (ch == \'@\') atenc = 1;\\n                if (plusenc && !atenc) continue;\\n                processed << ch;\\n            }\\n\\n            track.insert(processed.str());\\n        }\\n\\n        return track.size();\\n    }\\n};","number":"929"},"933":{"link":"https://leetcode.com/problems/number-of-recent-calls","name":"Number of Recent Calls","difficulty":"Easy","statement":"<div><p>Write a class <code>RecentCounter</code> to count recent requests.</p>\\n\\n<p>It has only one method:&nbsp;<code>ping(int t)</code>, where t represents some time in milliseconds.</p>\\n\\n<p>Return the number of <code>ping</code>s that have been made from 3000 milliseconds ago until now.</p>\\n\\n<p>Any ping with time in <code>[t - 3000, t]</code> will count, including the current ping.</p>\\n\\n<p>It is guaranteed that every call to <code>ping</code> uses a strictly larger value of&nbsp;<code>t</code> than before.</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong>inputs = <span id=\\"example-input-1-1\\">[\\"RecentCounter\\",\\"ping\\",\\"ping\\",\\"ping\\",\\"ping\\"]</span>, inputs = <span id=\\"example-input-1-2\\">[[],[1],[100],[3001],[3002]]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">[null,1,2,3,3]</span></pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ol>\\n\\t<li>Each test case will have at most <code>10000</code> calls to <code>ping</code>.</li>\\n\\t<li>Each test case will call&nbsp;<code>ping</code> with strictly increasing values of <code>t</code>.</li>\\n\\t<li>Each call to ping will have <code>1 &lt;= t &lt;= 10^9</code>.</li>\\n</ol>\\n\\n<div>\\n<p>&nbsp;</p>\\n</div></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass RecentCounter\\n{\\n\\npublic:\\n    vector<int> pings;\\n    int size;\\n    int lastIndex;\\n\\n    RecentCounter()\\n    {\\n        this->lastIndex = 0;\\n        this->size = 0;\\n    }\\n\\n    int ping(int t)\\n    {\\n        this->pings.push_back(t);\\n        ++this->size;\\n        for (; this->lastIndex < this->size && this->pings[this->lastIndex] < t - 3000; ++this->lastIndex)\\n            ;\\n        return this->size - this->lastIndex;\\n    }\\n};","number":"933"},"938":{"link":"https://leetcode.com/problems/range-sum-of-bst","name":"Range Sum of BST","difficulty":"Easy","statement":"<div><p>Given the <code>root</code> node of a binary search tree, return the sum of values of all nodes with value between <code>L</code> and <code>R</code> (inclusive).</p>\\n\\n<p>The binary search tree is guaranteed to have unique values.</p>\\n\\n<p>&nbsp;</p>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong>root = <span id=\\"example-input-1-1\\">[10,5,15,3,7,null,18]</span>, L = <span id=\\"example-input-1-2\\">7</span>, R = <span id=\\"example-input-1-3\\">15</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">32</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong>root = <span id=\\"example-input-2-1\\">[10,5,15,3,7,13,18,1,null,6]</span>, L = <span id=\\"example-input-2-2\\">6</span>, R = <span id=\\"example-input-2-3\\">10</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">23</span>\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ol>\\n\\t<li>The number of nodes in the tree is at most <code>10000</code>.</li>\\n\\t<li>The final answer is guaranteed to be less than <code>2^31</code>.</li>\\n</ol>\\n</div>\\n</div></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    int rangeSumBST(TreeNode *root, int L, int R)\\n    {\\n\\n        int sum = 0;\\n        if (root)\\n        {\\n            sum = root->val >= L && root->val <= R ? root->val : 0;\\n            sum += rangeSumBST(root->left, L, R);\\n            sum += rangeSumBST(root->right, L, R);\\n        }\\n\\n        return sum;\\n    }\\n};","number":"938"},"942":{"link":"https://leetcode.com/problems/di-string-match","name":"DI String Match","difficulty":"Easy","statement":"<div><p>Given a string <code>S</code> that <strong>only</strong> contains \\"I\\" (increase) or \\"D\\" (decrease), let <code>N = S.length</code>.</p>\\n\\n<p>Return <strong>any</strong> permutation <code>A</code> of <code>[0, 1, ..., N]</code> such that for all <code>i = 0,&nbsp;..., N-1</code>:</p>\\n\\n<ul>\\n\\t<li>If <code>S[i] == \\"I\\"</code>, then <code>A[i] &lt; A[i+1]</code></li>\\n\\t<li>If <code>S[i] == \\"D\\"</code>, then <code>A[i] &gt; A[i+1]</code></li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">\\"IDID\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">[0,4,1,3,2]</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">\\"III\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">[0,1,2,3]</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-3-1\\">\\"DDI\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-3\\">[3,2,0,1]</span></pre>\\n</div>\\n</div>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ol>\\n\\t<li><code>1 &lt;= S.length &lt;= 10000</code></li>\\n\\t<li><code>S</code> only contains characters <code>\\"I\\"</code> or <code>\\"D\\"</code>.</li>\\n</ol></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> diStringMatch(string S) {\\n\\n        vector<int> res;\\n\\n        int n = S.length();\\n\\n        if (S[0] == \'I\') res.push_back(0);\\n        else res.push_back(n);\\n\\n        int ICount = count(S.begin(), S.end(), \'I\');\\n        int DCount = n - ICount;\\n\\n        int I, D;\\n        if (S[0] == \'I\') {\\n            D = DCount;\\n            I = D+1;\\n        }\\n        else {\\n            D = DCount - 1;\\n            I = D+1;\\n        }\\n\\n        for(char i: S) {\\n            if (i == \'I\') res.push_back(I++);\\n            else res.push_back(D--);\\n        }\\n\\n        return res;\\n\\n    }\\n};","number":"942"},"944":{"link":"https://leetcode.com/problems/delete-columns-to-make-sorted","name":"Delete Columns to Make Sorted","difficulty":"Easy","statement":"<div><p>We are given an array&nbsp;<code>A</code> of <code>N</code> lowercase letter strings, all of the same length.</p>\\n\\n<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>\\n\\n<p>For example, if we have an array <code>A = [\\"abcdef\\",\\"uvwxyz\\"]</code> and deletion indices <code>{0, 2, 3}</code>, then the final array after deletions is <code>[\\"bef\\", \\"vyz\\"]</code>,&nbsp;and the remaining columns of <code>A</code> are&nbsp;<code>[\\"b\\",\\"v\\"]</code>, <code>[\\"e\\",\\"y\\"]</code>, and <code>[\\"f\\",\\"z\\"]</code>.&nbsp; (Formally, the <code>c</code>-th column is <code>[A[0][c], A[1][c], ..., A[A.length-1][c]]</code>).</p>\\n\\n<p>Suppose we chose a set of deletion indices <code>D</code> such that after deletions, each remaining column in A is in <strong>non-decreasing</strong> sorted order.</p>\\n\\n<p>Return the minimum possible value of <code>D.length</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> A = [\\"cba\\",\\"daf\\",\\"ghi\\"]\\n<strong>Output:</strong> 1\\n<strong>Explanation: </strong>\\nAfter choosing D = {1}, each column [\\"c\\",\\"d\\",\\"g\\"] and [\\"a\\",\\"f\\",\\"i\\"] are in non-decreasing sorted order.\\nIf we chose D = {}, then a column [\\"b\\",\\"a\\",\\"h\\"] would not be in non-decreasing sorted order.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> A = [\\"a\\",\\"b\\"]\\n<strong>Output:</strong> 0\\n<strong>Explanation: </strong>D = {}\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> A = [\\"zyx\\",\\"wvu\\",\\"tsr\\"]\\n<strong>Output:</strong> 3\\n<strong>Explanation: </strong>D = {0, 1, 2}\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= A.length &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= A[i].length &lt;= 1000</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int minDeletionSize(vector<string> &A)\\n    {\\n\\n        int len = A[0].length();\\n        int n = A.size();\\n\\n        int del[len];\\n        fill_n(del, len, 0);\\n\\n        for(int i = 0; i < n-1; i++) {\\n            for(int j = 0; j < len; j++) {\\n                if (A[i][j] > A[i+1][j]) {\\n                    del[j] = 1;\\n                    \\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for(int i: del)\\n            count += i;\\n\\n        return count;\\n\\n    }\\n};","number":"944"},"961":{"link":"https://leetcode.com/problems/n-repeated-element-in-size-2n-array","name":"N-Repeated Element in Size 2N Array","difficulty":"Easy","statement":"<div><p>In a array <code>A</code> of size <code>2N</code>, there are <code>N+1</code> unique elements, and exactly one of these elements is repeated <code>N</code> times.</p>\\n\\n<p>Return the element repeated <code>N</code> times.</p>\\n\\n<p>&nbsp;</p>\\n\\n<ol>\\n</ol>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[1,2,3,3]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">3</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">[2,1,2,5,3,2]</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">2</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-3-1\\">[5,1,5,2,5,3,5,4]</span>\\n<strong>Output: </strong><span id=\\"example-output-3\\">5</span>\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ul>\\n\\t<li><code>4 &lt;= A.length &lt;= 10000</code></li>\\n\\t<li><code>0 &lt;= A[i] &lt; 10000</code></li>\\n\\t<li><code>A.length</code> is even</li>\\n</ul>\\n</div>\\n</div>\\n</div>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int repeatedNTimes(vector<int>& A) {\\n\\n        int v[100001];\\n        fill_n(v, 100001, 0);\\n        for(int i: A) if (v[i]++) return i;\\n\\n    }\\n};","number":"961"},"965":{"link":"https://leetcode.com/problems/univalued-binary-tree","name":"Univalued Binary Tree","difficulty":"Easy","statement":"<div><p>A binary tree is <em>univalued</em> if every node in the tree has the same value.</p>\\n\\n<p>Return <code>true</code>&nbsp;if and only if the given tree is univalued.</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Example 1:</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2018/12/28/unival_bst_1.png\\" style=\\"width: 265px; height: 172px;\\">\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[1,1,1,1,1,null,1]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">true</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2018/12/28/unival_bst_2.png\\" style=\\"width: 198px; height: 169px;\\">\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">[2,2,2,5,2]</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">false</span>\\n</pre>\\n</div>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ol>\\n\\t<li>The number of nodes in the given tree will be in the range <code>[1, 100]</code>.</li>\\n\\t<li>Each node\'s value will be an integer in the range <code>[0, 99]</code>.</li>\\n</ol>\\n</div>","language":"c","solution":"\\nstruct TreeNode\\n{\\n    int val;\\n    struct TreeNode *left;\\n    struct TreeNode *right;\\n};\\n\\nbool isUnivalTree(struct TreeNode *root)\\n{\\n    if(!root) return true;\\n    if(root->left) {\\n        if (root->left->val != root->val) return false;\\n        if (!isUnivalTree(root->left)) return false;\\n    }\\n    if(root->right) {\\n        if (root->right->val != root->val) return false;\\n        if (!isUnivalTree(root->right)) return false;\\n    }\\n\\n    return true;\\n\\n}","number":"965"},"977":{"link":"https://leetcode.com/problems/squares-of-a-sorted-array","name":"Squares of a Sorted Array","difficulty":"Easy","statement":"<div><p>Given an array of integers <code>A</code>&nbsp;sorted in non-decreasing order,&nbsp;return an array of the squares of each number,&nbsp;also in sorted non-decreasing order.</p>\\n\\n<p>&nbsp;</p>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[-4,-1,0,3,10]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">[0,1,9,16,100]</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">[-7,-3,2,3,11]</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">[4,9,9,49,121]</span>\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong><span>Note:</span></strong></p>\\n\\n<ol>\\n\\t<li><code><span>1 &lt;= A.length &lt;= 10000</span></code></li>\\n\\t<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>\\n\\t<li><code>A</code>&nbsp;is sorted in non-decreasing order.</li>\\n</ol>\\n</div>\\n</div></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> sortedSquares(vector<int>& A) {\\n\\n        vector<int> res;\\n\\n        for(int i: A) res.push_back(i*i);\\n\\n        sort(res.begin(), res.end());\\n\\n        return res;\\n        \\n    }\\n};","number":"977"},"1002":{"link":"https://leetcode.com/problems/find-common-characters","name":"Find Common Characters","difficulty":"Easy","statement":"<div><p>Given an array&nbsp;<code>A</code> of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list <strong>(including duplicates)</strong>.&nbsp;&nbsp;For example, if a character occurs 3 times&nbsp;in all strings but not 4 times, you need to include that character three times&nbsp;in the final answer.</p>\\n\\n<p>You may return the answer in any order.</p>\\n\\n<p>&nbsp;</p>\\n\\n<div>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">[\\"bella\\",\\"label\\",\\"roller\\"]</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">[\\"e\\",\\"l\\",\\"l\\"]</span>\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">[\\"cool\\",\\"lock\\",\\"cook\\"]</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">[\\"c\\",\\"o\\"]</span>\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong><span>Note:</span></strong></p>\\n\\n<ol>\\n\\t<li><code>1 &lt;= A.length &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= A[i].length &lt;= 100</code></li>\\n\\t<li><code>A[i][j]</code> is a lowercase letter</li>\\n</ol>\\n</div>\\n</div></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<string> commonChars(vector<string> &A)\\n    {\\n\\n        int len = A.size();\\n        vector<vector<int>> m;\\n        for (int i = 0; i < 26; i++)\\n        {\\n            vector<int> t;\\n            for (string temp : A)\\n                t.push_back(0);\\n            m.push_back(t);\\n        }\\n\\n        for (int i = 0; i < len; ++i)\\n        {\\n            for (char ch : A[i])\\n            {\\n                ++m[(int)(ch)-97][i];\\n            }\\n        }\\n\\n        vector<string> out;\\n\\n        for (int i = 0; i < 26; i++)\\n        {\\n            vector<int> counts = m[i];\\n            int min_count = *min_element(counts.begin(), counts.end());\\n            stringstream s;\\n            s << (char)(i + 97);\\n            for (int j = 0; j < min_count; ++j)\\n            {\\n                out.push_back(s.str());\\n            }\\n        }\\n\\n        return out;\\n    }\\n};","number":"1002"},"1021":{"link":"https://leetcode.com/problems/remove-outermost-parentheses","name":"Remove Outermost Parentheses","difficulty":"Easy","statement":"<div><p>A valid parentheses string is either empty <code>(\\"\\")</code>, <code>\\"(\\" + A + \\")\\"</code>, or <code>A + B</code>, where <code>A</code> and <code>B</code> are valid parentheses strings, and <code>+</code> represents string concatenation.&nbsp; For example, <code>\\"\\"</code>, <code>\\"()\\"</code>, <code>\\"(())()\\"</code>, and <code>\\"(()(()))\\"</code> are all valid parentheses strings.</p>\\n\\n<p>A valid parentheses string <code>S</code> is <strong>primitive</strong> if it is nonempty, and there does not exist a way to split it into <code>S = A+B</code>, with <code>A</code> and <code>B</code> nonempty valid parentheses strings.</p>\\n\\n<p>Given a valid parentheses string <code>S</code>, consider its primitive decomposition: <code>S = P_1 + P_2 + ... + P_k</code>, where <code>P_i</code> are primitive valid parentheses strings.</p>\\n\\n<p>Return <code>S</code> after removing the outermost parentheses of every primitive string in the primitive decomposition of <code>S</code>.</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">\\"(()())(())\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">\\"()()()\\"</span>\\n<strong>Explanation: </strong>\\nThe input string is \\"(()())(())\\", with primitive decomposition \\"(()())\\" + \\"(())\\".\\nAfter removing outer parentheses of each part, this is \\"()()\\" + \\"()\\" = \\"()()()\\".\\n</pre>\\n\\n<div>\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-2-1\\">\\"(()())(())(()(()))\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">\\"()()()()(())\\"</span>\\n<strong>Explanation: </strong>\\nThe input string is \\"(()())(())(()(()))\\", with primitive decomposition \\"(()())\\" + \\"(())\\" + \\"(()(()))\\".\\nAfter removing outer parentheses of each part, this is \\"()()\\" + \\"()\\" + \\"()(())\\" = \\"()()()()(())\\".\\n</pre>\\n\\n<div>\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-3-1\\">\\"()()\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-3\\">\\"\\"</span>\\n<strong>Explanation: </strong>\\nThe input string is \\"()()\\", with primitive decomposition \\"()\\" + \\"()\\".\\nAfter removing outer parentheses of each part, this is \\"\\" + \\"\\" = \\"\\".\\n</pre>\\n\\n<p>&nbsp;</p>\\n</div>\\n</div>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ol>\\n\\t<li><code>S.length &lt;= 10000</code></li>\\n\\t<li><code>S[i]</code> is <code>\\"(\\"</code> or <code>\\")\\"</code></li>\\n\\t<li><code>S</code> is a valid parentheses string</li>\\n</ol>\\n\\n<div>\\n<div>\\n<div>&nbsp;</div>\\n</div>\\n</div></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    string removeOuterParentheses(string S)\\n    {\\n\\n        int n = S.length();\\n        char res[n];\\n\\n        fill_n(res, n, \'\\\\0\');\\n\\n        int pos = 0;\\n        int diff = 0;\\n        for (char i : S)\\n        {\\n\\n            if (i == \'(\')\\n            {\\n                if (diff)\\n                {\\n                    res[pos] = \'(\';\\n                    ++pos;\\n                }\\n                ++diff;\\n            }\\n            else\\n            {\\n                --diff;\\n                if (diff)\\n                {\\n                    res[pos] = \')\';\\n                    ++pos;\\n                }\\n            }\\n        }\\n\\n        string r(res);\\n\\n        return r;\\n    }\\n};","number":"1021"},"1022":{"link":"https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers","name":"Sum of Root To Leaf Binary Numbers","difficulty":"Easy","statement":"<div><p>You are given the <code>root</code> of a binary tree where each node has a value <code>0</code>&nbsp;or <code>1</code>.&nbsp; Each root-to-leaf path represents a binary number starting with the most significant bit.&nbsp; For example, if the path is <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>, then this could represent <code>01101</code> in binary, which is <code>13</code>.</p>\\n\\n<p>For all leaves in the tree, consider the numbers represented by the path&nbsp;from the root to that leaf.</p>\\n\\n<p>Return <em>the sum of these numbers</em>. The answer is <strong>guaranteed</strong> to fit in a <strong>32-bits</strong> integer.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png\\" style=\\"width: 450px; height: 296px;\\">\\n<pre><strong>Input:</strong> root = [1,0,1,0,1,0,1]\\n<strong>Output:</strong> 22\\n<strong>Explanation: </strong>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> root = [0]\\n<strong>Output:</strong> 0\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> root = [1]\\n<strong>Output:</strong> 1\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> root = [1,1]\\n<strong>Output:</strong> 3\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li>The number of nodes in the tree is in the range <code>[1, 1000]</code>.</li>\\n\\t<li><code>Node.val</code> is <code>0</code> or <code>1</code>.</li>\\n</ul>\\n</div>","language":"c","solution":"#include <stdio.h>\\n\\nstruct TreeNode\\n{\\n    int val;\\n    struct TreeNode *left;\\n    struct TreeNode *right;\\n};\\n\\nint sumRootToLeaf(struct TreeNode *root)\\n{\\n    return findSum(root, 0);\\n}\\n\\nint findSum(struct TreeNode *root, int prevSum) {\\n\\n    int sum = 0;\\n\\n    if (root->left)\\n        sum += findSum(root->left, 2*prevSum + root->val);\\n    if (root->right)\\n        sum += findSum(root->right, 2*prevSum + root->val);\\n\\n    if (!root->left && !root->right)\\n        return prevSum*2 + root->val;\\n    return sum;\\n\\n}","number":"1022"},"1047":{"link":"https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string","name":"Remove All Adjacent Duplicates In String","difficulty":"Easy","statement":"<div><p>Given a string <code>S</code> of lowercase letters, a <em>duplicate removal</em> consists of choosing two adjacent and equal letters, and removing&nbsp;them.</p>\\n\\n<p>We repeatedly make duplicate removals on S until we no longer can.</p>\\n\\n<p>Return the final string after all such duplicate removals have been made.&nbsp; It is guaranteed the answer is unique.</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong><span id=\\"example-input-1-1\\">\\"abbaca\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">\\"ca\\"</span>\\n<strong>Explanation: </strong>\\nFor example, in \\"abbaca\\" we could remove \\"bb\\" since the letters are adjacent and equal, and this is the only possible move.&nbsp; The result of this move is that the string is \\"aaca\\", of which only \\"aa\\" is possible, so the final string is \\"ca\\".\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Note:</strong></p>\\n\\n<ol>\\n\\t<li><code>1 &lt;= S.length &lt;= 20000</code></li>\\n\\t<li><code>S</code> consists only of English lowercase letters.</li>\\n</ol></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    string removeDuplicates(string S)\\n    {\\n\\n        stringstream out;\\n        vector<char> s;\\n        for (char ch : S)\\n            s.push_back(ch);\\n\\n        int n = S.length();\\n\\n        for (int i = 0; i < n - 1; i++)\\n        {\\n            \\n            if (s[i] == s[i + 1])\\n            {\\n\\n                s.erase(s.begin() + i+1);\\n                s.erase(s.begin() + i);\\n\\n                i -= 2;\\n                n -= 2;\\n\\n                if (i < -1)\\n                    i = -1;\\n\\n            }\\n        }\\n\\n        for(char ch: s) out << ch;\\n\\n        return out.str();\\n    }\\n};","number":"1047"},"1051":{"link":"https://leetcode.com/problems/height-checker","name":"Height Checker","difficulty":"Easy","statement":"<div><p>Students are asked to stand in non-decreasing order of heights for an annual photo.</p>\\n\\n<p>Return the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.</p>\\n\\n<p>Notice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students&nbsp;remain on their seats.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> heights = [1,1,4,2,1,3]\\n<strong>Output:</strong> 3\\n<strong>Explanation:</strong> \\nCurrent array : [1,1,4,2,1,3]\\nTarget array  : [1,1,1,2,3,4]\\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> heights = [5,1,2,3,4]\\n<strong>Output:</strong> 5\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> heights = [1,2,3,4,5]\\n<strong>Output:</strong> 0\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= heights.length &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= heights[i] &lt;= 100</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int heightChecker(vector<int> &heights)\\n    {\\n\\n        vector<int> dup = heights;\\n        sort(dup.begin(), dup.end());\\n        int count = 0;\\n        int n = heights.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (dup[i] != heights[i])\\n                ++count;\\n        }\\n\\n        return count;\\n    }\\n};","number":"1051"},"1079":{"link":"https://leetcode.com/problems/letter-tile-possibilities","name":"Letter Tile Possibilities","difficulty":"Medium","statement":"<div><p>You have <code>n</code>&nbsp;&nbsp;<code>tiles</code>, where each tile has one letter <code>tiles[i]</code> printed on it.</p>\\n\\n<p>Return <em>the number of possible non-empty sequences of letters</em> you can make using the letters printed on those <code>tiles</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> tiles = \\"AAB\\"\\n<strong>Output:</strong> 8\\n<strong>Explanation: </strong>The possible sequences are \\"A\\", \\"B\\", \\"AA\\", \\"AB\\", \\"BA\\", \\"AAB\\", \\"ABA\\", \\"BAA\\".\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> tiles = \\"AAABBC\\"\\n<strong>Output:</strong> 188\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> tiles = \\"V\\"\\n<strong>Output:</strong> 1\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= tiles.length &lt;= 7</code></li>\\n\\t<li><code>tiles</code> consists of uppercase English letters.</li>\\n</ul>\\n</div>","language":"py","solution":"import itertools as it\\n\\nclass Solution:\\n    def numTilePossibilities(self, tiles: str) -> int:\\n        n = len(tiles)\\n        \\n        res = 0\\n        for i in range(1, n+1):\\n            res += len(set(list(it.permutations(tiles, i))))\\n            \\n        return res","number":"1079"},"1108":{"link":"https://leetcode.com/problems/defanging-an-ip-address","name":"Defanging an IP Address","difficulty":"Easy","statement":"<div><p>Given a valid (IPv4) IP <code>address</code>, return a defanged version of that IP address.</p>\\n\\n<p>A <em>defanged&nbsp;IP address</em>&nbsp;replaces every period <code>\\".\\"</code> with <code>\\"[.]\\"</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n<pre><strong>Input:</strong> address = \\"1.1.1.1\\"\\n<strong>Output:</strong> \\"1[.]1[.]1[.]1\\"\\n</pre><p><strong>Example 2:</strong></p>\\n<pre><strong>Input:</strong> address = \\"255.100.50.0\\"\\n<strong>Output:</strong> \\"255[.]100[.]50[.]0\\"\\n</pre>\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li>The given <code>address</code> is a valid IPv4 address.</li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    string defangIPaddr(string address)\\n    {\\n\\n        int a, b, c, d;\\n\\n        char arr[address.length() + 1];\\n\\n        strcpy(arr, address.c_str());\\n\\n        sscanf(arr, \\"%d.%d.%d.%d\\", &a, &b, &c, &d);\\n\\n        char res_arr[address.length() + 1 + 10];\\n\\n        sprintf(res_arr, \\"%d[.]%d[.]%d[.]%d\\", a, b, c, d);\\n\\n        string res(res_arr);\\n\\n        return res;\\n    }\\n};","number":"1108"},"1122":{"link":"https://leetcode.com/problems/relative-sort-array","name":"Relative Sort Array","difficulty":"Easy","statement":"<div><p>Given two arrays <code>arr1</code> and <code>arr2</code>, the elements of <code>arr2</code> are distinct, and all elements in <code>arr2</code> are also in <code>arr1</code>.</p>\\n\\n<p>Sort the elements of <code>arr1</code> such that the relative ordering of items in <code>arr1</code> are the same as in <code>arr2</code>.&nbsp; Elements that don\'t appear in <code>arr2</code> should be placed at the end of <code>arr1</code> in <strong>ascending</strong> order.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n<pre><strong>Input:</strong> arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\\n<strong>Output:</strong> [2,2,2,1,4,3,3,9,6,7,19]\\n</pre>\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>arr1.length, arr2.length &lt;= 1000</code></li>\\n\\t<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li>\\n\\t<li>Each&nbsp;<code>arr2[i]</code>&nbsp;is&nbsp;distinct.</li>\\n\\t<li>Each&nbsp;<code>arr2[i]</code> is in <code>arr1</code>.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> relativeSortArray(vector<int> &arr1, vector<int> &arr2)\\n    {\\n\\n        int *m1 = (int *)malloc(sizeof(int) * 1001);\\n        fill_n(m1, 1001, 0);\\n\\n        for (int i : arr1)\\n            ++m1[i];\\n\\n        int *m2 = (int *)malloc(sizeof(int) * 1001);\\n        fill_n(m2, 1001, 0);\\n\\n        for (int i : arr2)\\n            ++m2[i];\\n\\n        vector<int> out;\\n        vector<int> exc;\\n\\n        for (int i : arr2)\\n        {\\n            if (m2[i])\\n            {\\n                int count = m1[i];\\n                for (int j = 0; j < count; ++j)\\n                {\\n                    out.push_back(i);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i <= 1000; ++i)\\n        {\\n            if (!m2[i])\\n            {\\n                int count = m1[i];\\n                for (int j = 0; j < count; ++j)\\n                {\\n                    exc.push_back(i);\\n                }\\n            }\\n        }\\n\\n        sort(exc.begin(), exc.end());\\n        for (int i : exc)\\n            out.push_back(i);\\n\\n        return out;\\n    }\\n};","number":"1122"},"1160":{"link":"https://leetcode.com/problems/find-words-that-can-be-formed-by-characters","name":"Find Words That Can Be Formed by Characters","difficulty":"Easy","statement":"<div><p>You are given an array of strings&nbsp;<code>words</code>&nbsp;and a string&nbsp;<code>chars</code>.</p>\\n\\n<p>A string is <em>good</em>&nbsp;if&nbsp;it can be formed by&nbsp;characters from <code>chars</code>&nbsp;(each character&nbsp;can only be used once).</p>\\n\\n<p>Return the sum of lengths of all good strings in <code>words</code>.</p>\\n\\n<p>&nbsp;</p>\\n\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input: </strong>words = <span id=\\"example-input-1-1\\">[\\"cat\\",\\"bt\\",\\"hat\\",\\"tree\\"]</span>, chars = <span id=\\"example-input-1-2\\">\\"atach\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-1\\">6</span>\\n<strong>Explanation: </strong>\\nThe strings that can be formed are \\"cat\\" and \\"hat\\" so the answer is 3 + 3 = 6.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input: </strong>words = <span id=\\"example-input-2-1\\">[\\"hello\\",\\"world\\",\\"leetcode\\"]</span>, chars = <span id=\\"example-input-2-2\\">\\"welldonehoneyr\\"</span>\\n<strong>Output: </strong><span id=\\"example-output-2\\">10</span>\\n<strong>Explanation: </strong>\\nThe strings that can be formed are \\"hello\\" and \\"world\\" so the answer is 5 + 5 = 10.\\n</pre>\\n\\n<p>&nbsp;</p>\\n\\n<p><span><strong>Note:</strong></span></p>\\n\\n<ol>\\n\\t<li><code>1 &lt;= words.length &lt;= 1000</code></li>\\n\\t<li><code>1 &lt;= words[i].length, chars.length&nbsp;&lt;= 100</code></li>\\n\\t<li>All strings contain lowercase English letters only.</li>\\n</ol></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int countCharacters(vector<string> &words, string chars)\\n    {\\n\\n        int sum = 0;\\n        int *count = (int *)malloc(sizeof(int) * 26);\\n        fill_n(count, 26, 0);\\n\\n        for (char ch : chars)\\n        {\\n            ++count[(int)(ch)-97];\\n        }\\n\\n        for (string s : words)\\n        {\\n            int *count_t = (int *)malloc(sizeof(int) * 26);\\n            fill_n(count_t, 26, 0);\\n\\n            for (char ch : s)\\n            {\\n                ++count_t[(int)(ch)-97];\\n            }\\n\\n            int check = 1;\\n\\n            for(int i = 0;  i < 26; i++) {\\n                if (count_t[i] > count[i]) {\\n                    check = 0;\\n                    break;\\n                }\\n            }\\n\\n            if (check) sum += s.length();\\n        }\\n        return sum;\\n    }\\n};","number":"1160"},"1207":{"link":"https://leetcode.com/problems/unique-number-of-occurrences","name":"Unique Number of Occurrences","difficulty":"Easy","statement":"<div><p>Given an array of integers <code>arr</code>,&nbsp;write a function that returns <code>true</code> if and only if the number of occurrences of each value in the array is unique.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [1,2,2,1,1,3]\\n<strong>Output:</strong> true\\n<strong>Explanation:</strong>&nbsp;The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [1,2]\\n<strong>Output:</strong> false\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [-3,0,1,-3,1,1,1,-3,10,0]\\n<strong>Output:</strong> true\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 1000</code></li>\\n\\t<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool uniqueOccurrences(vector<int>& arr) {\\n\\n        vector<int> count;\\n        for(int i = 0; i < 2001; i++) {\\n            count.push_back(0);\\n        }\\n\\n        for (int i: arr)\\n            ++count[i+1000];\\n\\n        sort(count.begin(), count.end());\\n        int n = count.size();\\n        \\n        for(int i = 0; i < n - 1; i++) {\\n            if (count[i] > 0 && count[i] == count[i+1]) return false;\\n        }\\n        return true;\\n        \\n    }\\n};","number":"1207"},"1221":{"link":"https://leetcode.com/problems/split-a-string-in-balanced-strings","name":"Split a String in Balanced Strings","difficulty":"Easy","statement":"<div><p><i data-stringify-type=\\"italic\\">Balanced</i>&nbsp;strings are those who have equal quantity of \'L\' and \'R\' characters.</p>\\n\\n<p>Given a balanced string&nbsp;<code data-stringify-type=\\"code\\">s</code>&nbsp;split it in the maximum amount of balanced strings.</p>\\n\\n<p>Return the maximum amount of splitted balanced strings.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"RLRRLLRLRL\\"\\n<strong>Output:</strong> 4\\n<strong>Explanation: </strong>s can be split into \\"RL\\", \\"RRLL\\", \\"RL\\", \\"RL\\", each substring contains same number of \'L\' and \'R\'.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"RLLLLRRRLR\\"\\n<strong>Output:</strong> 3\\n<strong>Explanation: </strong>s can be split into \\"RL\\", \\"LLLRRR\\", \\"LR\\", each substring contains same number of \'L\' and \'R\'.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"LLLLRRRR\\"\\n<strong>Output:</strong> 1\\n<strong>Explanation: </strong>s can be split into \\"LLLLRRRR\\".\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"RLRRRLLRLL\\"\\n<strong>Output:</strong> 2\\n<strong>Explanation: </strong>s can be split into \\"RL\\", \\"RRRLLRLL\\", since each substring contains an equal number of \'L\' and \'R\'\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\\n\\t<li><code>s[i] = \'L\' or \'R\'</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int balancedStringSplit(string s)\\n    {\\n\\n        int count = 0;\\n        int diff = 0;\\n        int n = s.length();\\n\\n        for(char i: s) {\\n            if (i == \'L\') diff--;\\n            else diff++;\\n\\n            if (diff == 0){\\n                count ++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};","number":"1221"},"1237":{"link":"https://leetcode.com/problems/find-positive-integer-solution-for-a-given-equation","name":"Find Positive Integer Solution for a Given Equation","difficulty":"Medium","statement":"<div><p>Given a callable function <code>f(x, y)</code> <strong>with a hidden formula</strong> and a value <code>z</code>, reverse engineer the formula and return <em>all positive integer pairs </em><code>x</code><em> and </em><code>y</code><em> where </em><code>f(x,y) == z</code>. You may return the pairs in any order.</p>\\n\\n<p>While the exact formula is hidden, the function is monotonically increasing, i.e.:</p>\\n\\n<ul>\\n\\t<li><code>f(x, y) &lt; f(x + 1, y)</code></li>\\n\\t<li><code>f(x, y) &lt; f(x, y + 1)</code></li>\\n</ul>\\n\\n<p>The function interface is defined like this:</p>\\n\\n<pre>interface CustomFunction {\\npublic:\\n  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.\\n  int f(int x, int y);\\n};\\n</pre>\\n\\n<p>We will judge your solution as follows:</p>\\n\\n<ul>\\n\\t<li>The judge has a list of <code>9</code> hidden implementations of <code>CustomFunction</code>, along with a way to generate an <strong>answer key</strong> of all valid pairs for a specific <code>z</code>.</li>\\n\\t<li>The judge will receive two inputs: a <code>function_id</code> (to determine which implementation to test your code with), and the target <code>z</code>.</li>\\n\\t<li>The judge will call your <code>findSolution</code> and compare your results with the <strong>answer key</strong>.</li>\\n\\t<li>If your results match the <strong>answer key</strong>, your solution will be <code>Accepted</code>.</li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> function_id = 1, z = 5\\n<strong>Output:</strong> [[1,4],[2,3],[3,2],[4,1]]\\n<strong>Explanation:</strong> The hidden formula for function_id = 1 is f(x, y) = x + y.\\nThe following positive integer values of x and y make f(x, y) equal to 5:\\nx=1, y=4 -&gt; f(1, 4) = 1 + 4 = 5.\\nx=2, y=3 -&gt; f(2, 3) = 2 + 3 = 5.\\nx=3, y=2 -&gt; f(3, 2) = 3 + 2 = 5.\\nx=4, y=1 -&gt; f(4, 1) = 4 + 1 = 5.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> function_id = 2, z = 5\\n<strong>Output:</strong> [[1,5],[5,1]]\\n<strong>Explanation:</strong> The hidden formula for function_id = 2 is f(x, y) = x * y.\\nThe following positive integer values of x and y make f(x, y) equal to 5:\\nx=1, y=5 -&gt; f(1, 5) = 1 * 5 = 5.\\nx=5, y=1 -&gt; f(5, 1) = 5 * 1 = 5.\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= function_id &lt;= 9</code></li>\\n\\t<li><code>1 &lt;= z &lt;= 100</code></li>\\n\\t<li>It is guaranteed that the solutions of <code>f(x, y) == z</code> will be in the range <code>1 &lt;= x, y &lt;= 1000</code>.</li>\\n\\t<li>It is also guaranteed that <code>f(x, y)</code> will fit in 32 bit signed integer if <code>1 &lt;= x, y &lt;= 1000</code>.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass CustomFunction\\n{\\npublic:\\n    // Returns f(x, y) for any given positive integers x and y.\\n    // Note that f(x, y) is increasing with respect to both x and y.\\n    // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\\n    int f(int x, int y);\\n};\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> findSolution(CustomFunction &customfunction, int z)\\n    {\\n\\n        vector<vector<int>> res;\\n        for (int x = 1; x <= 1000; x++)\\n        {\\n            for (int y = 1; y <= 1000; y++)\\n            {\\n                int val = customfunction.f(x, y);\\n                if (val == z)\\n                {\\n                    vector<int> r = {x, y};\\n                    res.push_back(r);\\n                    break;\\n                }\\n                if (val > z)\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};","number":"1237"},"1252":{"link":"https://leetcode.com/problems/cells-with-odd-values-in-a-matrix","name":"Cells with Odd Values in a Matrix","difficulty":"Easy","statement":"<div><p>Given&nbsp;<code>n</code>&nbsp;and&nbsp;<code>m</code>&nbsp;which are the dimensions of a matrix initialized by zeros and given an array <code>indices</code>&nbsp;where <code>indices[i] = [ri, ci]</code>. For each pair of <code>[ri, ci]</code>&nbsp;you have to increment all cells in row <code>ri</code> and column <code>ci</code>&nbsp;by 1.</p>\\n\\n<p>Return <em>the number of cells with odd values</em> in the matrix after applying the increment to all <code>indices</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/10/30/e1.png\\" style=\\"width: 600px; height: 118px;\\">\\n<pre><strong>Input:</strong> n = 2, m = 3, indices = [[0,1],[1,1]]\\n<strong>Output:</strong> 6\\n<strong>Explanation:</strong> Initial matrix = [[0,0,0],[0,0,0]].\\nAfter applying first increment it becomes [[1,2,1],[0,1,0]].\\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/10/30/e2.png\\" style=\\"width: 600px; height: 150px;\\">\\n<pre><strong>Input:</strong> n = 2, m = 2, indices = [[1,1],[0,0]]\\n<strong>Output:</strong> 0\\n<strong>Explanation:</strong> Final matrix = [[2,2],[2,2]]. There is no odd number in the final matrix.\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= n &lt;= 50</code></li>\\n\\t<li><code>1 &lt;= m &lt;= 50</code></li>\\n\\t<li><code>1 &lt;= indices.length &lt;= 100</code></li>\\n\\t<li><code>0 &lt;= indices[i][0] &lt;&nbsp;n</code></li>\\n\\t<li><code>0 &lt;= indices[i][1] &lt;&nbsp;m</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int oddCells(int n, int m, vector<vector<int>> &indices)\\n    {\\n\\n        int arr[n][m];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            fill_n(arr[i], m, 0);\\n        }\\n\\n        for (vector<int> i : indices)\\n        {\\n            int r = i[0];\\n            int c = i[1];\\n\\n            for (int k = 0; k < m; k++)\\n            {\\n                ++arr[r][k];\\n            }\\n\\n            for (int k = 0; k < n; k++)\\n            {\\n                ++arr[k][c];\\n            }\\n        }\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j: arr[i]) {\\n                count += j%2;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};","number":"1252"},"1266":{"link":"https://leetcode.com/problems/minimum-time-visiting-all-points","name":"Minimum Time Visiting All Points","difficulty":"Easy","statement":"<div><p>On a plane there are <code>n</code> points with integer coordinates <code>points[i] = [xi, yi]</code>. Your task is to find the minimum time in seconds to visit all points.</p>\\n\\n<p>You can move according to the next rules:</p>\\n\\n<ul>\\n\\t<li>In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second).</li>\\n\\t<li>You have to visit the points in the same order as they appear in the array.</li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/11/14/1626_example_1.PNG\\" style=\\"width: 500px; height: 428px;\\">\\n<pre><strong>Input:</strong> points = [[1,1],[3,4],[-1,0]]\\n<strong>Output:</strong> 7\\n<strong>Explanation: </strong>One optimal path is <strong>[1,1]</strong> -&gt; [2,2] -&gt; [3,3] -&gt; <strong>[3,4] </strong>-&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; <strong>[-1,0]</strong>   \\nTime from [1,1] to [3,4] = 3 seconds \\nTime from [3,4] to [-1,0] = 4 seconds\\nTotal time = 7 seconds</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> points = [[3,2],[-2,2]]\\n<strong>Output:</strong> 5\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>points.length == n</code></li>\\n\\t<li><code>1 &lt;= n&nbsp;&lt;= 100</code></li>\\n\\t<li><code>points[i].length == 2</code></li>\\n\\t<li><code>-1000&nbsp;&lt;= points[i][0], points[i][1]&nbsp;&lt;= 1000</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\\n\\n        int cost = 0;\\n        int n = points.size();\\n\\n        for(int i = 0; i < n - 1; i++) {\\n\\n            vector<int> a = points[i];\\n            vector<int> b = points[i+1];\\n\\n            cost += max(abs(a[0]-b[0]), abs(a[1]-b[1]));\\n\\n            cout << cost << endl;\\n\\n        }\\n        return cost;\\n        \\n    }\\n};","number":"1266"},"1281":{"link":"https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer","name":"Subtract the Product and Sum of Digits of an Integer","difficulty":"Easy","statement":"<div>Given an integer number <code>n</code>, return the difference between the product of its digits and the sum of its digits.\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 234\\n<strong>Output:</strong> 15 \\n<b>Explanation:</b> \\nProduct of digits = 2 * 3 * 4 = 24 \\nSum of digits = 2 + 3 + 4 = 9 \\nResult = 24 - 9 = 15\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 4421\\n<strong>Output:</strong> 21\\n<b>Explanation: \\n</b>Product of digits = 4 * 4 * 2 * 1 = 32 \\nSum of digits = 4 + 4 + 2 + 1 = 11 \\nResult = 32 - 11 = 21\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int sum = 0;\\n        int prod = 1;\\n\\n        while (n) {\\n            int rem = n % 10;\\n            sum += rem;\\n            prod *= rem;\\n            n /= 10;\\n        }\\n\\n        if (sum > prod) {\\n            return sum - prod;\\n        }\\n        return prod - sum;\\n    }\\n};","number":"1281"},"1290":{"link":"https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer","name":"Convert Binary Number in a Linked List to Integer","difficulty":"Easy","statement":"<div><p>Given <code>head</code> which is a reference node to&nbsp;a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.</p>\\n\\n<p>Return the <em>decimal value</em> of the number in the linked list.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2019/12/05/graph-1.png\\" style=\\"width: 426px; height: 108px;\\">\\n<pre><strong>Input:</strong> head = [1,0,1]\\n<strong>Output:</strong> 5\\n<strong>Explanation:</strong> (101) in base 2 = (5) in base 10\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> head = [0]\\n<strong>Output:</strong> 0\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> head = [1]\\n<strong>Output:</strong> 1\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]\\n<strong>Output:</strong> 18880\\n</pre>\\n\\n<p><strong>Example 5:</strong></p>\\n\\n<pre><strong>Input:</strong> head = [0,0]\\n<strong>Output:</strong> 0\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li>The Linked List is not empty.</li>\\n\\t<li>Number of nodes&nbsp;will not exceed <code>30</code>.</li>\\n\\t<li>Each node\'s value is either&nbsp;<code>0</code> or <code>1</code>.</li>\\n</ul></div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int getDecimalValue(ListNode* head) {\\n\\n        int res = 0;\\n\\n        while(head) {\\n            res = res*2 + head->val;\\n            head = head->next;\\n        }\\n\\n        return res;\\n        \\n    }\\n};","number":"1290"},"1295":{"link":"https://leetcode.com/problems/find-numbers-with-even-number-of-digits","name":"Find Numbers with Even Number of Digits","difficulty":"Easy","statement":"<div>Given an array <code>nums</code> of integers, return how many of them contain an <strong>even number</strong> of digits.\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [12,345,2,6,7896]\\n<strong>Output:</strong> 2\\n<strong>Explanation: \\n</strong>12 contains 2 digits (even number of digits).&nbsp;\\n345 contains 3 digits (odd number of digits).&nbsp;\\n2 contains 1 digit (odd number of digits).&nbsp;\\n6 contains 1 digit (odd number of digits).&nbsp;\\n7896 contains 4 digits (even number of digits).&nbsp;\\nTherefore only 12 and 7896 contain an even number of digits.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [555,901,482,1771]\\n<strong>Output:</strong> 1 \\n<strong>Explanation: </strong>\\nOnly 1771 contains an even number of digits.\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\\n\\t<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n#include <cmath> \\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int findNumbers(vector<int>& nums) {\\n\\n        int count = 0;\\n        for (int i: nums) {\\n            if ((int)ceil(log10(i+1)) % 2 == 0)\\n                count ++;\\n        }\\n\\n        return count;\\n        \\n    }\\n};","number":"1295"},"1299":{"link":"https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side","name":"Replace Elements with Greatest Element on Right Side","difficulty":"Easy","statement":"<div><p>Given an array <code>arr</code>,&nbsp;replace every element in that array with the greatest element among the elements to its&nbsp;right, and replace the last element with <code>-1</code>.</p>\\n\\n<p>After doing so, return the array.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n<pre><strong>Input:</strong> arr = [17,18,5,4,6,1]\\n<strong>Output:</strong> [18,6,6,6,1,-1]\\n</pre>\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>\\n\\t<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> replaceElements(vector<int>& arr) {\\n\\n        vector<int> res;\\n        int n = arr.size();\\n        for (int i: arr) {\\n            res.push_back(-1);\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            for(int j = i+1; j < n; j++) {\\n                if (arr[j] > res[i]) {\\n                    res[i] = arr[j];\\n                }\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n};","number":"1299"},"1304":{"link":"https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero","name":"Find N Unique Integers Sum up to Zero","difficulty":"Easy","statement":"<div><p>Given an integer <code>n</code>, return <strong>any</strong> array containing <code>n</code> <strong>unique</strong>&nbsp;integers such that they add up to 0.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 5\\n<strong>Output:</strong> [-7,-1,1,3,4]\\n<strong>Explanation:</strong> These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 3\\n<strong>Output:</strong> [-1,0,1]\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 1\\n<strong>Output:</strong> [0]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= n &lt;= 1000</code></li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> sumZero(int n) {\\n\\n        vector<int> res;\\n\\n        for (int i = 1; i <= (n/2); i++) {\\n            res.push_back(i);\\n            res.push_back(i*-1);\\n        }\\n\\n        if (n%2)\\n            res.push_back(0);\\n\\n        return res;\\n        \\n    }\\n};","number":"1304"},"1309":{"link":"https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping","name":"Decrypt String from Alphabet to Integer Mapping","difficulty":"Easy","statement":"<div><p>Given a string <code>s</code> formed by digits (<code>\'0\'</code> - <code>\'9\'</code>)&nbsp;and <code>\'#\'</code>&nbsp;.&nbsp;We want to map <code>s</code> to English lowercase characters as follows:</p>\\n\\n<ul>\\n\\t<li>Characters (<code>\'a\'</code> to <code>\'i\')</code> are&nbsp;represented by&nbsp;(<code>\'1\'</code> to&nbsp;<code>\'9\'</code>)&nbsp;respectively.</li>\\n\\t<li>Characters (<code>\'j\'</code> to <code>\'z\')</code> are represented by (<code>\'10#\'</code>&nbsp;to&nbsp;<code>\'26#\'</code>)&nbsp;respectively.&nbsp;</li>\\n</ul>\\n\\n<p>Return the string formed after mapping.</p>\\n\\n<p>It\'s guaranteed that a unique mapping will always exist.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"10#11#12\\"\\n<strong>Output:</strong> \\"jkab\\"\\n<strong>Explanation:</strong> \\"j\\" -&gt; \\"10#\\" , \\"k\\" -&gt; \\"11#\\" , \\"a\\" -&gt; \\"1\\" , \\"b\\" -&gt; \\"2\\".\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"1326#\\"\\n<strong>Output:</strong> \\"acz\\"\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"25#\\"\\n<strong>Output:</strong> \\"y\\"\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#\\"\\n<strong>Output:</strong> \\"abcdefghijklmnopqrstuvwxyz\\"\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\\n\\t<li><code>s[i]</code> only contains digits letters (<code>\'0\'</code>-<code>\'9\'</code>) and <code>\'#\'</code>&nbsp;letter.</li>\\n\\t<li><code>s</code> will be valid string&nbsp;such that mapping is always possible.</li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    string freqAlphabets(string s) {\\n\\n        stringstream res;\\n\\n        int n = s.length();\\n\\n        for(int i = 0; i < n; i++) {\\n            if (i+2 < n && s[i+2] == \'#\') {\\n\\n                int a = (int)s[i] - 48;\\n                int b = (int)s[i+1] - 48;\\n\\n                char r = (char)(106 + (a-1)*10 + b);\\n                res << r;\\n                i += 2;\\n            }\\n            else {\\n                char r = (char)((int)s[i] + 48);\\n                res << r;\\n            }\\n        }\\n\\n        return res.str();\\n        \\n    }\\n};","number":"1309"},"1313":{"link":"https://leetcode.com/problems/decompress-run-length-encoded-list","name":"Decompress Run-Length Encoded List","difficulty":"Easy","statement":"<div><p>We are given a list <code>nums</code> of integers representing a list compressed with run-length encoding.</p>\\n\\n<p>Consider each adjacent pair&nbsp;of elements <code>[freq, val] = [nums[2*i], nums[2*i+1]]</code>&nbsp;(with <code>i &gt;= 0</code>).&nbsp; For each such pair, there are <code>freq</code> elements with value <code>val</code> concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.</p>\\n\\n<p>Return the decompressed list.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,2,3,4]\\n<strong>Output:</strong> [2,4,4,4]\\n<strong>Explanation:</strong> The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].\\nThe second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].\\nAt the end the concatenation [2] + [4,4,4] is [2,4,4,4].\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,1,2,3]\\n<strong>Output:</strong> [1,3,3]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\\n\\t<li><code>nums.length % 2 == 0</code></li>\\n\\t<li><code><font face=\\"monospace\\">1 &lt;= nums[i] &lt;= 100</font></code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> decompressRLElist(vector<int>& nums) {\\n\\n        int n = nums.size();\\n\\n        vector<int> res;\\n\\n        for (int i = 0; i < n / 2; i ++) {\\n            for(int j = 0; j < nums[2*i]; j ++) {\\n                res.push_back(nums[2*i + 1]);\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n};","number":"1313"},"1323":{"link":"https://leetcode.com/problems/maximum-69-number","name":"Maximum 69 Number","difficulty":"Easy","statement":"<div><p>Given a positive integer <code>num</code> consisting only of digits 6 and 9.</p>\\n\\n<p>Return the maximum number you can get by changing <strong>at most</strong> one digit (6 becomes 9, and 9 becomes 6).</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> num = 9669\\n<strong>Output:</strong> 9969\\n<strong>Explanation:</strong> \\nChanging the first digit results in 6669.\\nChanging the second digit results in 9969.\\nChanging the third digit results in 9699.\\nChanging the fourth digit results in 9666.&nbsp;\\nThe maximum number is 9969.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> num = 9996\\n<strong>Output:</strong> 9999\\n<strong>Explanation:</strong> Changing the last digit 6 to 9 results in the maximum number.</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> num = 9999\\n<strong>Output:</strong> 9999\\n<strong>Explanation:</strong> It is better not to apply any change.</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= num &lt;= 10^4</code></li>\\n\\t<li><code>num</code>\'s digits are 6 or 9.</li>\\n</ul></div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n#include <string.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int maximum69Number (int num) {\\n\\n        int temp = num;\\n        \\n        int mult = 1;\\n        int val = 0;\\n\\n        while(num) {\\n            int rem = num%10;\\n            if (rem == 6) {\\n                val = 3*mult;\\n            }\\n            mult *= 10;\\n            num /= 10;\\n        }\\n\\n        return temp + val;\\n    }\\n};","number":"1323"},"1337":{"link":"https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix","name":"The K Weakest Rows in a Matrix","difficulty":"Easy","statement":"<div><p>Given a <code>m&nbsp;* n</code>&nbsp;matrix <code>mat</code> of <em>ones</em>&nbsp;(representing soldiers) and <em>zeros</em>&nbsp;(representing civilians), return the indexes of the <code>k</code> weakest rows in the matrix ordered from the weakest to the strongest.</p>\\n\\n<p>A row <em><strong>i</strong></em> is weaker than row <em><strong>j</strong></em>, if the number of soldiers in row <em><strong>i</strong></em> is less than the number of soldiers in row <em><strong>j</strong></em>, or they have the same number of soldiers but <em><strong>i</strong></em> is less than <em><strong>j</strong></em>. Soldiers are <strong>always</strong> stand in the frontier of a row, that is, always <em>ones</em>&nbsp;may appear first and then <em>zeros</em>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> mat = \\n[[1,1,0,0,0],\\n [1,1,1,1,0],\\n [1,0,0,0,0],\\n [1,1,0,0,0],\\n [1,1,1,1,1]], \\nk = 3\\n<strong>Output:</strong> [2,0,3]\\n<strong>Explanation:</strong> \\nThe number of soldiers for each row is: \\nrow 0 -&gt; 2 \\nrow 1 -&gt; 4 \\nrow 2 -&gt; 1 \\nrow 3 -&gt; 2 \\nrow 4 -&gt; 5 \\nRows ordered from the weakest to the strongest are [2,0,3,1,4]\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> mat = \\n[[1,0,0,0],\\n&nbsp;[1,1,1,1],\\n&nbsp;[1,0,0,0],\\n&nbsp;[1,0,0,0]], \\nk = 2\\n<strong>Output:</strong> [0,2]\\n<strong>Explanation:</strong> \\nThe number of soldiers for each row is: \\nrow 0 -&gt; 1 \\nrow 1 -&gt; 4 \\nrow 2 -&gt; 1 \\nrow 3 -&gt; 1 \\nRows ordered from the weakest to the strongest are [0,2,3,1]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>m == mat.length</code></li>\\n\\t<li><code>n == mat[i].length</code></li>\\n\\t<li><code><font face=\\"monospace\\">2 &lt;= n, m &lt;= 100</font></code></li>\\n\\t<li><code>1 &lt;= k &lt;= m</code></li>\\n\\t<li><code>matrix[i][j]</code> is either 0 <strong>or</strong> 1.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> kWeakestRows(vector<vector<int>> &mat, int k)\\n    {\\n\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        int *arr = (int *)malloc(sizeof(int) * m);\\n        fill_n(arr, m, 0);\\n\\n        vector<int> output;\\n        output.reserve(k);\\n\\n        int done = 0;\\n\\n        for (int i = 0; i < n && done < k; i++)\\n        {\\n            for (int j = 0; j < m && done < k; j++)\\n            {\\n                if (!(mat[j][i] || arr[j]))\\n                {\\n                    output.push_back(j);\\n                    arr[j] = 1;\\n                    ++done;\\n                }\\n            }\\n        }\\n\\n        if (done != k) {\\n            for(int i = 0; i < m && done < k; i++) {\\n                if (!arr[i]) {\\n                    ++done;\\n                    output.push_back(i);\\n                }\\n            }\\n        }\\n\\n\\n        return output;\\n    }\\n};","number":"1337"},"1342":{"link":"https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero","name":"Number of Steps to Reduce a Number to Zero","difficulty":"Easy","statement":"<div><p>Given a non-negative integer <code>num</code>, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> num = 14\\n<strong>Output:</strong> 6\\n<strong>Explanation:</strong>&nbsp;\\nStep 1) 14 is even; divide by 2 and obtain 7.&nbsp;\\nStep 2) 7 is odd; subtract 1 and obtain 6.\\nStep 3) 6 is even; divide by 2 and obtain 3.&nbsp;\\nStep 4) 3 is odd; subtract 1 and obtain 2.&nbsp;\\nStep 5) 2 is even; divide by 2 and obtain 1.&nbsp;\\nStep 6) 1 is odd; subtract 1 and obtain 0.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> num = 8\\n<strong>Output:</strong> 4\\n<strong>Explanation:</strong>&nbsp;\\nStep 1) 8 is even; divide by 2 and obtain 4.&nbsp;\\nStep 2) 4 is even; divide by 2 and obtain 2.&nbsp;\\nStep 3) 2 is even; divide by 2 and obtain 1.&nbsp;\\nStep 4) 1 is odd; subtract 1 and obtain 0.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> num = 123\\n<strong>Output:</strong> 12\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>0 &lt;= num &lt;= 10^6</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int numberOfSteps(int num)\\n    {\\n        int count = 0;\\n\\n        while (num != 0)\\n        {\\n            count++;\\n            if (num % 2 == 0)\\n            {\\n                num /= 2;\\n            }\\n            else {\\n                num -= 1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n};","number":"1342"},"1351":{"link":"https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix","name":"Count Negative Numbers in a Sorted Matrix","difficulty":"Easy","statement":"<div><p>Given a <code>m&nbsp;* n</code>&nbsp;matrix <code>grid</code>&nbsp;which is sorted in non-increasing order both row-wise and column-wise.&nbsp;</p>\\n\\n<p>Return the number of <strong>negative</strong> numbers in&nbsp;<code>grid</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\\n<strong>Output:</strong> 8\\n<strong>Explanation:</strong> There are 8 negatives number in the matrix.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> grid = [[3,2],[1,0]]\\n<strong>Output:</strong> 0\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> grid = [[1,-1],[-1,-1]]\\n<strong>Output:</strong> 3\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> grid = [[-1]]\\n<strong>Output:</strong> 1\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>m == grid.length</code></li>\\n\\t<li><code>n == grid[i].length</code></li>\\n\\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\\n\\t<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int countNegatives(vector<vector<int>>& grid) {\\n\\n        int count = 0;\\n\\n        for(vector<int> x: grid) {\\n            for(int a: x) {\\n                if (a < 0) ++count;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};","number":"1351"},"1356":{"link":"https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits","name":"Sort Integers by The Number of 1 Bits","difficulty":"Easy","statement":"<div><p>Given an integer array <code>arr</code>. You have to sort the integers in the array&nbsp;in ascending order by the number of <strong>1\'s</strong>&nbsp;in their binary representation and in case of two or more integers have the same number of <strong>1\'s</strong> you have to sort them in ascending order.</p>\\n\\n<p>Return <em>the sorted array</em>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [0,1,2,3,4,5,6,7,8]\\n<strong>Output:</strong> [0,1,2,4,8,3,5,6,7]\\n<strong>Explantion:</strong> [0] is the only integer with 0 bits.\\n[1,2,4,8] all have 1 bit.\\n[3,5,6] have 2 bits.\\n[7] has 3 bits.\\nThe sorted array by bits is [0,1,2,4,8,3,5,6,7]\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [1024,512,256,128,64,32,16,8,4,2,1]\\n<strong>Output:</strong> [1,2,4,8,16,32,64,128,256,512,1024]\\n<strong>Explantion:</strong> All integers have 1 bit in the binary representation, you should just sort them in ascending order.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [10000,10000]\\n<strong>Output:</strong> [10000,10000]\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [2,3,5,7,11,13,17,19]\\n<strong>Output:</strong> [2,3,5,17,7,11,13,19]\\n</pre>\\n\\n<p><strong>Example 5:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [10,100,1000,10000]\\n<strong>Output:</strong> [10,100,10000,1000]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= arr.length &lt;= 500</code></li>\\n\\t<li><code>0 &lt;= arr[i] &lt;= 10^4</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nint one_count(int a) {\\n    if (a == 0) return 0;\\n    return a % 2 + one_count(a / 2);\\n}\\n\\nbool comp(int a, int b)\\n{\\n    int c = one_count(a);\\n    int d = one_count(b);\\n    if (c == d) {\\n        return a < b;\\n    }\\n    return c < d;\\n}\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> sortByBits(vector<int> &arr)\\n    {\\n        sort(arr.begin(), arr.end());\\n        sort(arr.begin(), arr.end(), comp);\\n        return arr;\\n    }\\n};","number":"1356"},"1365":{"link":"https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number","name":"How Many Numbers Are Smaller Than the Current Number","difficulty":"Easy","statement":"<div><p>Given the array <code>nums</code>, for each <code>nums[i]</code> find out how many numbers in the array are smaller than it. That is, for each <code>nums[i]</code> you have to count the number of valid <code>j\'s</code>&nbsp;such that&nbsp;<code>j != i</code> <strong>and</strong> <code>nums[j] &lt; nums[i]</code>.</p>\\n\\n<p>Return the answer in an array.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [8,1,2,2,3]\\n<strong>Output:</strong> [4,0,1,1,3]\\n<strong>Explanation:</strong> \\nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \\nFor nums[1]=1 does not exist any smaller number than it.\\nFor nums[2]=2 there exist one smaller number than it (1). \\nFor nums[3]=2 there exist one smaller number than it (1). \\nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [6,5,4,8]\\n<strong>Output:</strong> [2,1,0,3]\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [7,7,7,7]\\n<strong>Output:</strong> [0,0,0,0]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\\n\\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int> &nums)\\n    {\\n\\n        vector<int> temp = nums;\\n\\n        sort(temp.begin(), temp.end());\\n\\n        int first_pos[101];\\n        fill_n(first_pos, 101, -1);\\n\\n        int n = temp.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            if (first_pos[temp[i]] == -1) {\\n                first_pos[temp[i]] = i;\\n            }\\n        }\\n\\n        vector<int> res;\\n\\n        for (int i = 0; i < n; i++) {\\n            res.push_back(first_pos[nums[i]]);\\n        }\\n\\n        return res;\\n\\n\\n    }\\n};","number":"1365"},"1370":{"link":"https://leetcode.com/problems/increasing-decreasing-string","name":"Increasing Decreasing String","difficulty":"Easy","statement":"<div><p>Given a string <code>s</code>. You should re-order the string using the following algorithm:</p>\\n\\n<ol>\\n\\t<li>Pick the <strong>smallest</strong> character from <code>s</code> and <strong>append</strong> it to the result.</li>\\n\\t<li>Pick the <strong>smallest</strong> character from <code>s</code> which is greater than the last appended character to the result and <strong>append</strong> it.</li>\\n\\t<li>Repeat step 2 until you cannot pick more characters.</li>\\n\\t<li>Pick the <strong>largest</strong>&nbsp;character from <code>s</code> and <strong>append</strong> it to the result.</li>\\n\\t<li>Pick the <strong>largest</strong>&nbsp;character from <code>s</code> which is smaller than the last appended character to the result and <strong>append</strong> it.</li>\\n\\t<li>Repeat step 5 until you cannot pick more characters.</li>\\n\\t<li>Repeat the steps from 1 to 6 until you pick all characters from <code>s</code>.</li>\\n</ol>\\n\\n<p>In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.</p>\\n\\n<p>Return <em>the result string</em> after sorting <code>s</code>&nbsp;with this algorithm.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"aaaabbbbcccc\\"\\n<strong>Output:</strong> \\"abccbaabccba\\"\\n<strong>Explanation:</strong> After steps 1, 2 and 3 of the first iteration, result = \\"abc\\"\\nAfter steps 4, 5 and 6 of the first iteration, result = \\"abccba\\"\\nFirst iteration is done. Now s = \\"aabbcc\\" and we go back to step 1\\nAfter steps 1, 2 and 3 of the second iteration, result = \\"abccbaabc\\"\\nAfter steps 4, 5 and 6 of the second iteration, result = \\"abccbaabccba\\"\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"rat\\"\\n<strong>Output:</strong> \\"art\\"\\n<strong>Explanation:</strong> The word \\"rat\\" becomes \\"art\\" after re-ordering it with the mentioned algorithm.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"leetcode\\"\\n<strong>Output:</strong> \\"cdelotee\\"\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"ggggggg\\"\\n<strong>Output:</strong> \\"ggggggg\\"\\n</pre>\\n\\n<p><strong>Example 5:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"spo\\"\\n<strong>Output:</strong> \\"ops\\"\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\\n\\t<li><code>s</code> contains only lower-case English letters.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    string sortString(string s) {\\n\\n        int n = s.length();\\n\\n        int count[26];\\n        fill_n(count, 26, 0);\\n\\n        stringstream ss;\\n\\n        for(char i: s) {\\n            ++count[(int)(i) - 97];\\n        }\\n\\n        int max_count = -1;\\n        for(int i: count) {\\n            max_count = max_count > i ? max_count : i;\\n        }\\n\\n        for (int step = 1; step <= max_count; ++step ) {\\n\\n            for (int i = 0; i < 26; i++) {\\n                if (count[i] >= step) {\\n                    ss << (char)(i + 97);\\n                }\\n            }\\n\\n            ++step;\\n\\n            for (int i = 25; i >= 0; i--) {\\n                if (count[i] >= step) {\\n                    ss << (char)(i + 97);\\n                }\\n            }\\n\\n        }\\n\\n        return ss.str();\\n\\n    }\\n};","number":"1370"},"1374":{"link":"https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts","name":"Generate a String With Characters That Have Odd Counts","difficulty":"Easy","statement":"<div><p>Given an&nbsp;integer <code>n</code>, <em>return a string with <code>n</code>&nbsp;characters such that each character in such string occurs <strong>an odd number of times</strong></em>.</p>\\n\\n<p>The returned string must contain only lowercase English letters. If there are multiples valid strings, return <strong>any</strong> of them. &nbsp;</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 4\\n<strong>Output:</strong> \\"pppz\\"\\n<strong>Explanation:</strong> \\"pppz\\" is a valid string since the character \'p\' occurs three times and the character \'z\' occurs once. Note that there are many other valid strings such as \\"ohhh\\" and \\"love\\".\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 2\\n<strong>Output:</strong> \\"xy\\"\\n<strong>Explanation:</strong> \\"xy\\" is a valid string since the characters \'x\' and \'y\' occur once. Note that there are many other valid strings such as \\"ag\\" and \\"ur\\".\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 7\\n<strong>Output:</strong> \\"holasss\\"\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= n &lt;= 500</code></li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    string generateTheString(int n)\\n    {\\n\\n        stringstream ss;\\n\\n        if (n % 2)\\n        {\\n            for (int i = 0; i < n; i++)\\n            {\\n                ss << \'a\';\\n            }\\n        }\\n        else\\n        {\\n            for (int i = 0; i < n - 1; i++)\\n            {\\n                ss << \'a\';\\n            }\\n                ss << \'b\';\\n        }\\n\\n        return ss.str();\\n    }\\n};","number":"1374"},"1380":{"link":"https://leetcode.com/problems/lucky-numbers-in-a-matrix","name":"Lucky Numbers in a Matrix","difficulty":"Easy","statement":"<div><p>Given a <code>m * n</code> matrix of <strong>distinct </strong>numbers, return all lucky numbers in the&nbsp;matrix in <strong>any </strong>order.</p>\\n\\n<p>A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> matrix = [[3,7,8],[9,11,13],[15,16,17]]\\n<strong>Output:</strong> [15]\\n<strong>Explanation:</strong> 15 is the only lucky number since it is the minimum in its row and the maximum in its column\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]\\n<strong>Output:</strong> [12]\\n<strong>Explanation:</strong> 12 is the only lucky number since it is the minimum in its row and the maximum in its column.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> matrix = [[7,8],[1,2]]\\n<strong>Output:</strong> [7]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>m == mat.length</code></li>\\n\\t<li><code>n == mat[i].length</code></li>\\n\\t<li><code>1 &lt;= n, m &lt;= 50</code></li>\\n\\t<li><code>1 &lt;=&nbsp;matrix[i][j]&nbsp;&lt;= 10^5</code>.</li>\\n\\t<li>All elements in the matrix are distinct.</li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> luckyNumbers(vector<vector<int>> &matrix)\\n    {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        int min_row[m];\\n        int max_col[n];\\n\\n        fill_n(min_row, m, 1000000);\\n        fill_n(max_col, n, 0);\\n\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n            {\\n                min_row[i] = min_row[i] < matrix[i][j] ? min_row[i] : matrix[i][j];\\n                max_col[j] = max_col[j] > matrix[i][j] ? max_col[j] : matrix[i][j];\\n            }\\n\\n        vector<int> res;\\n\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (min_row[i] == matrix[i][j] && max_col[j] == matrix[i][j])\\n                    res.push_back(matrix[i][j]);\\n        \\n        return res;\\n    }\\n};","number":"1380"},"1389":{"link":"https://leetcode.com/problems/create-target-array-in-the-given-order","name":"Create Target Array in the Given Order","difficulty":"Easy","statement":"<div><p>Given two arrays of integers&nbsp;<code>nums</code> and <code>index</code>. Your task is to create <em>target</em> array under the following rules:</p>\\n\\n<ul>\\n\\t<li>Initially <em>target</em> array is empty.</li>\\n\\t<li>From left to right read nums[i] and index[i], insert at index <code>index[i]</code>&nbsp;the value <code>nums[i]</code>&nbsp;in&nbsp;<em>target</em> array.</li>\\n\\t<li>Repeat the previous step until there are no elements to read in <code>nums</code> and <code>index.</code></li>\\n</ul>\\n\\n<p>Return the <em>target</em> array.</p>\\n\\n<p>It is guaranteed that the insertion operations will be valid.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [0,1,2,3,4], index = [0,1,2,2,1]\\n<strong>Output:</strong> [0,4,1,3,2]\\n<strong>Explanation:</strong>\\nnums       index     target\\n0            0        [0]\\n1            1        [0,1]\\n2            2        [0,1,2]\\n3            2        [0,1,3,2]\\n4            1        [0,4,1,3,2]\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,2,3,4,0], index = [0,1,2,3,0]\\n<strong>Output:</strong> [0,1,2,3,4]\\n<strong>Explanation:</strong>\\nnums       index     target\\n1            0        [1]\\n2            1        [1,2]\\n3            2        [1,2,3]\\n4            3        [1,2,3,4]\\n0            0        [0,1,2,3,4]\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1], index = [0]\\n<strong>Output:</strong> [1]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>\\n\\t<li><code>nums.length == index.length</code></li>\\n\\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\\n\\t<li><code>0 &lt;= index[i] &lt;= i</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> createTargetArray(vector<int> &nums, vector<int> &index)\\n    {\\n\\n        int n = nums.size();\\n\\n        vector<int> res;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            res.insert(res.begin() + index[i], nums[i]);\\n        }\\n\\n        return res;\\n    }\\n};","number":"1389"},"1403":{"link":"https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order","name":"Minimum Subsequence in Non-Increasing Order","difficulty":"Easy","statement":"<div><p>Given the array <code>nums</code>, obtain a subsequence of the array whose sum of elements is <strong>strictly greater</strong> than the sum of the non&nbsp;included elements in such subsequence.&nbsp;</p>\\n\\n<p>If there are multiple solutions, return the subsequence with <strong>minimum size</strong> and if there still exist multiple solutions, return the subsequence with the <strong>maximum total sum</strong> of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.&nbsp;</p>\\n\\n<p>Note that the solution with the given constraints is guaranteed to be&nbsp;<strong>unique</strong>. Also return the answer sorted in <strong>non-increasing</strong> order.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [4,3,10,9,8]\\n<strong>Output:</strong> [10,9] \\n<strong>Explanation:</strong> The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included, however, the subsequence [10,9] has the maximum total sum of its elements.&nbsp;\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [4,4,7,6,7]\\n<strong>Output:</strong> [7,7,6] \\n<strong>Explanation:</strong> The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to returned in non-decreasing order.  \\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [6]\\n<strong>Output:</strong> [6]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\\n\\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> minSubsequence(vector<int>& nums) {\\n\\n        sort(nums.begin(), nums.end());\\n        reverse(nums.begin(), nums.end());\\n        int sum = 0;\\n        int totalsum = 0;\\n        vector<int> res;\\n\\n        for(int i: nums)\\n            totalsum += i;\\n\\n        for (int i: nums) {\\n            sum += i;\\n            res.push_back(i);\\n            if (sum > totalsum / 2) {\\n                break;\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n};","number":"1403"},"1431":{"link":"https://leetcode.com/problems/kids-with-the-greatest-number-of-candies","name":"Kids With the Greatest Number of Candies","difficulty":"Easy","statement":"<div><p>Given the array <code>candies</code> and the integer <code>extraCandies</code>, where <code>candies[i]</code> represents the number of candies that the <strong><em>ith</em></strong> kid has.</p>\\n\\n<p>For each kid check if there is a way to distribute <code>extraCandies</code> among the kids such that he or she can have the <strong>greatest</strong> number of candies among them.&nbsp;Notice that multiple kids can have the <strong>greatest</strong> number of candies.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> candies = [2,3,5,1,3], extraCandies = 3\\n<strong>Output:</strong> [true,true,true,false,true] \\n<strong>Explanation:</strong> \\nKid 1 has 2 candies and if he or she receives all extra candies (3) will have 5 candies --- the greatest number of candies among the kids. \\nKid 2 has 3 candies and if he or she receives at least 2 extra candies will have the greatest number of candies among the kids. \\nKid 3 has 5 candies and this is already the greatest number of candies among the kids. \\nKid 4 has 1 candy and even if he or she receives all extra candies will only have 4 candies. \\nKid 5 has 3 candies and if he or she receives at least 2 extra candies will have the greatest number of candies among the kids. \\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> candies = [4,2,1,1,2], extraCandies = 1\\n<strong>Output:</strong> [true,false,false,false,false] \\n<strong>Explanation:</strong> There is only 1 extra candy, therefore only kid 1 will have the greatest number of candies among the kids regardless of who takes the extra candy.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> candies = [12,1,12], extraCandies = 10\\n<strong>Output:</strong> [true,false,true]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>2 &lt;= candies.length &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= candies[i] &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= extraCandies &lt;= 50</code></li>\\n</ul></div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\\n        vector<bool> res;\\n        long int max = 0;\\n        for(int i  = 0; i < candies.size(); i++) {\\n            max = max > candies[i] ? max : candies[i];\\n        }\\n        for(int i: candies) {\\n            res.push_back(i + extraCandies >= max);\\n        }\\n        \\n        return res;\\n    }\\n};","number":"1431"},"1436":{"link":"https://leetcode.com/problems/destination-city","name":"Destination City","difficulty":"Easy","statement":"<div><p>You are given the array <code>paths</code>, where <code>paths[i] = [cityA<sub>i</sub>, cityB<sub>i</sub>]</code> means there&nbsp;exists a direct path going from <code>cityA<sub>i</sub></code> to <code>cityB<sub>i</sub></code>. <em>Return the destination city, that is, the city without any path outgoing to another city.</em></p>\\n\\n<p>It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> paths = [[\\"London\\",\\"New York\\"],[\\"New York\\",\\"Lima\\"],[\\"Lima\\",\\"Sao Paulo\\"]]\\n<strong>Output:</strong> \\"Sao Paulo\\" \\n<strong>Explanation:</strong> Starting at \\"London\\" city you will reach \\"Sao Paulo\\" city which is the destination city. Your trip consist of: \\"London\\" -&gt; \\"New York\\" -&gt; \\"Lima\\" -&gt; \\"Sao Paulo\\".\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> paths = [[\\"B\\",\\"C\\"],[\\"D\\",\\"B\\"],[\\"C\\",\\"A\\"]]\\n<strong>Output:</strong> \\"A\\"\\n<strong>Explanation:</strong> All possible trips are:&nbsp;\\n\\"D\\" -&gt; \\"B\\" -&gt; \\"C\\" -&gt; \\"A\\".&nbsp;\\n\\"B\\" -&gt; \\"C\\" -&gt; \\"A\\".&nbsp;\\n\\"C\\" -&gt; \\"A\\".&nbsp;\\n\\"A\\".&nbsp;\\nClearly the destination city is \\"A\\".\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> paths = [[\\"A\\",\\"Z\\"]]\\n<strong>Output:</strong> \\"Z\\"\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= paths.length &lt;= 100</code></li>\\n\\t<li><code>paths[i].length == 2</code></li>\\n\\t<li><code>1 &lt;=&nbsp;cityA<sub>i</sub>.length,&nbsp;cityB<sub>i</sub>.length &lt;= 10</code></li>\\n\\t<li><code>cityA<sub>i&nbsp;</sub><font face=\\"monospace\\">!=&nbsp;</font>cityB<sub>i</sub></code></li>\\n\\t<li>All strings&nbsp;consist of lowercase and uppercase English letters and the space character.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    string destCity(vector<vector<string>>& paths) {\\n        \\n\\n        set<string> all;\\n        for (vector<string> path: paths) {\\n            all.insert(path[0]);\\n            all.insert(path[1]);\\n        }\\n\\n        set<string> outonly;\\n        for (vector<string> path: paths) {\\n            outonly.insert(path[0]);\\n        }\\n\\n        string city;\\n\\n        for(string c: all) {\\n            if (outonly.find(c) == outonly.end()) {\\n                city = c;\\n                break;\\n            }\\n        }\\n\\n        return city;\\n\\n    }\\n};","number":"1436"},"1441":{"link":"https://leetcode.com/problems/build-an-array-with-stack-operations","name":"Build an Array With Stack Operations","difficulty":"Easy","statement":"<div><p>Given an array <code>target</code> and&nbsp;an integer <code>n</code>. In each iteration, you will read a number from &nbsp;<code>list = {1,2,3..., n}</code>.</p>\\n\\n<p>Build the <code>target</code>&nbsp;array&nbsp;using the following operations:</p>\\n\\n<ul>\\n\\t<li><strong>Push</strong>: Read a new element from the beginning&nbsp;<code>list</code>, and push it in the array.</li>\\n\\t<li><strong>Pop</strong>: delete the last element of&nbsp;the array.</li>\\n\\t<li>If the target array is already&nbsp;built, stop reading more elements.</li>\\n</ul>\\n\\n<p>You are guaranteed that the target array is strictly&nbsp;increasing, only containing&nbsp;numbers between 1 to <code>n</code>&nbsp;inclusive.</p>\\n\\n<p>Return the operations to build the target array.</p>\\n\\n<p>You are guaranteed that the answer is unique.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> target = [1,3], n = 3\\n<strong>Output:</strong> [\\"Push\\",\\"Push\\",\\"Pop\\",\\"Push\\"]\\n<strong>Explanation: \\n</strong>Read number 1 and automatically push in the array -&gt; [1]\\nRead number 2 and automatically push in the array then Pop it -&gt; [1]\\nRead number 3 and automatically push in the array -&gt; [1,3]\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> target = [1,2,3], n = 3\\n<strong>Output:</strong> [\\"Push\\",\\"Push\\",\\"Push\\"]\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> target = [1,2], n = 4\\n<strong>Output:</strong> [\\"Push\\",\\"Push\\"]\\n<strong>Explanation: </strong>You only need to read the first 2 numbers and stop.\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> target = [2,3,4], n = 4\\n<strong>Output:</strong> [\\"Push\\",\\"Pop\\",\\"Push\\",\\"Push\\",\\"Push\\"]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= target.length &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= target[i]&nbsp;&lt;= 100</code></li>\\n\\t<li><code>1 &lt;= n &lt;= 100</code></li>\\n\\t<li><code>target</code> is strictly&nbsp;increasing.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<string> buildArray(vector<int> &target, int n)\\n    {\\n\\n        string push = \\"Push\\";\\n        string pop = \\"Pop\\";\\n\\n        vector<string> res;\\n\\n        int index = 0;\\n\\n        for (int num = 1; index < target.size() && num <= n; ++num)\\n        {\\n            res.push_back(push);\\n            if (num == target[index])\\n            {\\n                ++index;\\n            }\\n            else\\n            {\\n                res.push_back(pop);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};","number":"1441"},"1450":{"link":"https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time","name":"Number of Students Doing Homework at a Given Time","difficulty":"Easy","statement":"<div><p>Given two integer arrays <code>startTime</code> and <code>endTime</code> and given an integer <code>queryTime</code>.</p>\\n\\n<p>The <code>ith</code> student started doing their homework at the time <code>startTime[i]</code> and finished it at time <code>endTime[i]</code>.</p>\\n\\n<p>Return <em>the number of students</em> doing their homework at time <code>queryTime</code>. More formally, return the number of students where <code>queryTime</code>&nbsp;lays in the interval <code>[startTime[i], endTime[i]]</code> inclusive.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\\n<strong>Output:</strong> 1\\n<strong>Explanation:</strong> We have 3 students where:\\nThe first student started doing homework at time 1 and finished at time 3 and wasn\'t doing anything at time 4.\\nThe second student started doing homework at time 2 and finished at time 2 and also wasn\'t doing anything at time 4.\\nThe third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> startTime = [4], endTime = [4], queryTime = 4\\n<strong>Output:</strong> 1\\n<strong>Explanation:</strong> The only student was doing their homework at the queryTime.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> startTime = [4], endTime = [4], queryTime = 5\\n<strong>Output:</strong> 0\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7\\n<strong>Output:</strong> 0\\n</pre>\\n\\n<p><strong>Example 5:</strong></p>\\n\\n<pre><strong>Input:</strong> startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5\\n<strong>Output:</strong> 5\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>startTime.length == endTime.length</code></li>\\n\\t<li><code>1 &lt;= startTime.length &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li>\\n\\t<li><code>1 &lt;=&nbsp;queryTime &lt;= 1000</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < startTime.size(); i++) {\\n            if (queryTime >= startTime[i] && queryTime <= endTime[i]) ++count;\\n        }\\n\\n        return count;\\n        \\n    }\\n};","number":"1450"},"1460":{"link":"https://leetcode.com/problems/make-two-arrays-equal-by-reversing-sub-arrays","name":"Make Two Arrays Equal by Reversing Sub-arrays","difficulty":"Easy","statement":"<div><p>Given two integer arrays of equal length <code>target</code> and <code>arr</code>.</p>\\n\\n<p>In one step, you can select any <strong>non-empty sub-array</strong> of <code>arr</code> and reverse it. You are allowed to make any number of steps.</p>\\n\\n<p>Return <em>True</em> if you can make <code>arr</code> equal to <code>target</code>, or <em>False</em> otherwise.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> target = [1,2,3,4], arr = [2,4,1,3]\\n<strong>Output:</strong> true\\n<strong>Explanation:</strong> You can follow the next steps to convert arr to target:\\n1- Reverse sub-array [2,4,1], arr becomes [1,4,2,3]\\n2- Reverse sub-array [4,2], arr becomes [1,2,4,3]\\n3- Reverse sub-array [4,3], arr becomes [1,2,3,4]\\nThere are multiple ways to convert arr to target, this is not the only way to do so.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> target = [7], arr = [7]\\n<strong>Output:</strong> true\\n<strong>Explanation:</strong> arr is equal to target without any reverses.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> target = [1,12], arr = [12,1]\\n<strong>Output:</strong> true\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> target = [3,7,9], arr = [3,7,11]\\n<strong>Output:</strong> false\\n<strong>Explanation:</strong> arr doesn\'t have value 9 and it can never be converted to target.\\n</pre>\\n\\n<p><strong>Example 5:</strong></p>\\n\\n<pre><strong>Input:</strong> target = [1,1,1,1,1], arr = [1,1,1,1,1]\\n<strong>Output:</strong> true\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>target.length == arr.length</code></li>\\n\\t<li><code>1 &lt;= target.length &lt;= 1000</code></li>\\n\\t<li><code>1 &lt;= target[i] &lt;= 1000</code></li>\\n\\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    bool canBeEqual(vector<int>& target, vector<int>& arr) {\\n\\n        sort(target.begin(), target.end());\\n        sort(arr.begin(), arr.end());\\n\\n        int n = target.size();\\n        int m = arr.size();\\n\\n        if (m!=n) return false;\\n        for(int i = 0; i < n; i++) {\\n            if (target[i] != arr[i]) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n};\\n","number":"1460"},"1464":{"link":"https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array","name":"Maximum Product of Two Elements in an Array","difficulty":"Easy","statement":"<div>Given the array of integers <code>nums</code>, you will choose two different indices <code>i</code> and <code>j</code> of that array. <em>Return the maximum value of</em> <code>(nums[i]-1)*(nums[j]-1)</code>.\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [3,4,5,2]\\n<strong>Output:</strong> 12 \\n<strong>Explanation:</strong> If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. \\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,5,4,5]\\n<strong>Output:</strong> 16\\n<strong>Explanation:</strong> Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [3,7]\\n<strong>Output:</strong> 12\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\\n\\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n\\n        sort(nums.begin(), nums.end());      \\n        int n = nums.size();\\n\\n        return (nums[n-1]-1)*(nums[n-2]-1);\\n    }\\n};","number":"1464"},"1470":{"link":"https://leetcode.com/problems/shuffle-the-array","name":"Shuffle the Array","difficulty":"Easy","statement":"<div><p>Given the array <code>nums</code> consisting of <code>2n</code> elements in the form <code>[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>,y<sub>1</sub>,y<sub>2</sub>,...,y<sub>n</sub>]</code>.</p>\\n\\n<p><em>Return the array in the form</em> <code>[x<sub>1</sub>,y<sub>1</sub>,x<sub>2</sub>,y<sub>2</sub>,...,x<sub>n</sub>,y<sub>n</sub>]</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [2,5,1,3,4,7], n = 3\\n<strong>Output:</strong> [2,3,5,4,1,7] \\n<strong>Explanation:</strong> Since x<sub>1</sub>=2, x<sub>2</sub>=5, x<sub>3</sub>=1, y<sub>1</sub>=3, y<sub>2</sub>=4, y<sub>3</sub>=7 then the answer is [2,3,5,4,1,7].\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,2,3,4,4,3,2,1], n = 4\\n<strong>Output:</strong> [1,4,2,3,3,2,4,1]\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,1,2,2], n = 2\\n<strong>Output:</strong> [1,2,1,2]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= n &lt;= 500</code></li>\\n\\t<li><code>nums.length == 2n</code></li>\\n\\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\\n</ul></div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> res;\\n        for(int i = 0; i < n; i++) {\\n            res.push_back(nums[i]);\\n            res.push_back(nums[i + n]);\\n        }\\n        return res;\\n    }\\n};","number":"1470"},"1475":{"link":"https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop","name":"Final Prices With a Special Discount in a Shop","difficulty":"Easy","statement":"<div><p>Given the array <code>prices</code> where <code>prices[i]</code> is the price of the <code>ith</code> item in a shop. There is a special discount for items in the shop, if you buy the <code>ith</code> item, then you will receive a discount equivalent to <code>prices[j]</code> where <code>j</code> is the <strong>minimum</strong>&nbsp;index such that <code>j &gt; i</code> and <code>prices[j] &lt;= prices[i]</code>, otherwise, you will not receive any discount at all.</p>\\n\\n<p><em>Return an array where the <code>ith</code> element is the final price you will pay for the <code>ith</code> item of the shop considering the special discount.</em></p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> prices = [8,4,6,2,3]\\n<strong>Output:</strong> [4,2,4,2,3]\\n<strong>Explanation:</strong>&nbsp;\\nFor item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.&nbsp;\\nFor item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.&nbsp;\\nFor item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.&nbsp;\\nFor items 3 and 4 you will not receive any discount at all.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> prices = [1,2,3,4,5]\\n<strong>Output:</strong> [1,2,3,4,5]\\n<strong>Explanation:</strong> In this case, for all items, you will not receive any discount at all.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> prices = [10,1,1,6]\\n<strong>Output:</strong> [9,0,1,6]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= prices.length &lt;= 500</code></li>\\n\\t<li><code>1 &lt;= prices[i] &lt;= 10^3</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> finalPrices(vector<int> &prices)\\n    {\\n\\n        int n = prices.size();\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i + 1; j < n; j++)\\n            {\\n                if (prices[j] <= prices[i])\\n                {\\n                    prices[i] -= prices[j];\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return prices;\\n    }\\n};","number":"1475"},"1480":{"link":"https://leetcode.com/problems/running-sum-of-1d-array","name":"Running Sum of 1d Array","difficulty":"Easy","statement":"<div><p>Given an array <code>nums</code>. We define a running sum of an array as&nbsp;<code>runningSum[i] = sum(nums[0]\u2026nums[i])</code>.</p>\\n\\n<p>Return the running sum of <code>nums</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,2,3,4]\\n<strong>Output:</strong> [1,3,6,10]\\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,1,1,1,1]\\n<strong>Output:</strong> [1,2,3,4,5]\\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [3,1,2,10,1]\\n<strong>Output:</strong> [3,4,6,16,17]\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\\n\\t<li><code>-10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6</code></li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> runningSum(vector<int> &nums)\\n    {\\n\\n        vector<int> res;\\n\\n        res.push_back(nums[0]);\\n\\n        int sum = res[0];\\n\\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            sum += nums[i];\\n            res.push_back(sum);\\n        }\\n\\n        return res;\\n    }\\n};","number":"1480"},"1486":{"link":"https://leetcode.com/problems/xor-operation-in-an-array","name":"XOR Operation in an Array","difficulty":"Easy","statement":"<div><p>Given an integer <code>n</code> and an integer <code>start</code>.</p>\\n\\n<p>Define an array <code>nums</code> where <code>nums[i] = start + 2*i</code> (0-indexed) and <code>n == nums.length</code>.</p>\\n\\n<p>Return the bitwise&nbsp;XOR&nbsp;of all elements of <code>nums</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 5, start = 0\\n<strong>Output:</strong> 8\\n<strong>Explanation: </strong>Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\\nWhere \\"^\\" corresponds to bitwise XOR operator.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 4, start = 3\\n<strong>Output:</strong> 8\\n<strong>Explanation: </strong>Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8.</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 1, start = 7\\n<strong>Output:</strong> 7\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> n = 10, start = 5\\n<strong>Output:</strong> 2\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= n &lt;= 1000</code></li>\\n\\t<li><code>0 &lt;= start &lt;= 1000</code></li>\\n\\t<li><code>n == nums.length</code></li>\\n</ul></div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int xorOperation(int n, int start) {\\n        int res = start;\\n\\n        for(int i = 1; i < n; i++) {\\n            res ^= (start + 2 * i);\\n        }\\n\\n        return res;\\n    }\\n};","number":"1486"},"1491":{"link":"https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary","name":"Average Salary Excluding the Minimum and Maximum Salary","difficulty":"Easy","statement":"<div><p>Given an array of <strong>unique</strong> integers <code>salary</code>&nbsp;where <code>salary[i]</code> is the salary of the employee <code>i</code>.</p>\\n\\n<p>Return the average salary of employees excluding the minimum and maximum salary.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> salary = [4000,3000,1000,2000]\\n<strong>Output:</strong> 2500.00000\\n<strong>Explanation: </strong>Minimum salary and maximum salary are 1000 and 4000 respectively.\\nAverage salary excluding minimum and maximum salary is (2000+3000)/2= 2500\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> salary = [1000,2000,3000]\\n<strong>Output:</strong> 2000.00000\\n<strong>Explanation: </strong>Minimum salary and maximum salary are 1000 and 3000 respectively.\\nAverage salary excluding minimum and maximum salary is (2000)/1= 2000\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> salary = [6000,5000,4000,3000,2000,1000]\\n<strong>Output:</strong> 3500.00000\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> salary = [8000,9000,2000,3000,6000,1000]\\n<strong>Output:</strong> 4750.00000\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>3 &lt;= salary.length &lt;= 100</code></li>\\n\\t<li><code>10^3&nbsp;&lt;= salary[i] &lt;= 10^6</code></li>\\n\\t<li><code>salary[i]</code> is unique.</li>\\n\\t<li>Answers within <code>10^-5</code> of the actual value will be accepted as correct.</li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    double average(vector<int> &salary)\\n    {\\n        sort(salary.begin(), salary.end());\\n        int n = salary.size();\\n        int sum = 0;\\n        for (double i : salary)\\n            sum += i;\\n        sum -= salary[0];\\n        sum -= salary[n - 1];\\n\\n        return (double)(sum / (double)(n - 2));\\n    }\\n};","number":"1491"},"1502":{"link":"https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence","name":"Can Make Arithmetic Progression From Sequence","difficulty":"Easy","statement":"<div><p>Given an array of numbers <code>arr</code>.&nbsp;A sequence of numbers is called an arithmetic progression&nbsp;if the difference between any two consecutive elements is the same.</p>\\n\\n<p>Return <code>true</code>&nbsp;if the array can be rearranged to form an arithmetic progression, otherwise, return <code>false</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [3,5,1]\\n<strong>Output:</strong> true\\n<strong>Explanation: </strong>We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [1,2,4]\\n<strong>Output:</strong> false\\n<strong>Explanation: </strong>There is no way to reorder the elements to obtain an arithmetic progression.\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>2 &lt;= arr.length &lt;= 1000</code></li>\\n\\t<li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    bool canMakeArithmeticProgression(vector<int> &arr)\\n    {\\n        sort(arr.begin(), arr.end());\\n        int diff;\\n        if (arr.size() > 1)\\n            diff = arr[1] - arr[0];\\n        for (int i = 0; i < arr.size() - 1; i++)\\n        {\\n            if (diff != arr[i + 1] - arr[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};","number":"1502"},"1512":{"link":"https://leetcode.com/problems/number-of-good-pairs","name":"Number of Good Pairs","difficulty":"Easy","statement":"<div><p>Given an array of integers&nbsp;<code>nums</code>.</p>\\n\\n<p>A pair&nbsp;<code>(i,j)</code>&nbsp;is called <em>good</em> if&nbsp;<code>nums[i]</code> == <code>nums[j]</code> and <code>i</code> &lt; <code>j</code>.</p>\\n\\n<p>Return the number of <em>good</em> pairs.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,2,3,1,1,3]\\n<strong>Output:</strong> 4\\n<strong>Explanation: </strong>There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,1,1,1]\\n<strong>Output:</strong> 6\\n<strong>Explanation: </strong>Each pair in the array are <em>good</em>.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> nums = [1,2,3]\\n<strong>Output:</strong> 0\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\\n</ul></div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int numIdenticalPairs(vector<int>& nums) {\\n\\n        int visited[101];\\n        fill_n(visited, 101, 0);\\n\\n        int count = 0;\\n\\n        for (int i: nums) {\\n            visited[i] += 1;\\n        }\\n\\n        for (int i: visited) {\\n            count += (i * (i-1)) / 2;\\n        }\\n\\n        return count;\\n    }\\n};","number":"1512"},"1528":{"link":"https://leetcode.com/problems/shuffle-string","name":"Shuffle String","difficulty":"Easy","statement":"<div><p>Given a string <code>s</code>&nbsp;and an integer array <code>indices</code> of the <strong>same length</strong>.</p>\\n\\n<p>The string <code>s</code> will be shuffled such that the character at the <code>i<sup>th</sup></code> position moves to&nbsp;<code>indices[i]</code> in the shuffled string.</p>\\n\\n<p>Return <em>the shuffled string</em>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/07/09/q1.jpg\\" style=\\"width: 321px; height: 243px;\\">\\n<pre><strong>Input:</strong> s = \\"codeleet\\", <code>indices</code> = [4,5,6,7,0,2,1,3]\\n<strong>Output:</strong> \\"leetcode\\"\\n<strong>Explanation:</strong> As shown, \\"codeleet\\" becomes \\"leetcode\\" after shuffling.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"abc\\", <code>indices</code> = [0,1,2]\\n<strong>Output:</strong> \\"abc\\"\\n<strong>Explanation:</strong> After shuffling, each character remains in its position.\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"aiohn\\", <code>indices</code> = [3,1,4,2,0]\\n<strong>Output:</strong> \\"nihao\\"\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"aaiougrt\\", <code>indices</code> = [4,0,2,6,7,3,1,5]\\n<strong>Output:</strong> \\"arigatou\\"\\n</pre>\\n\\n<p><strong>Example 5:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"art\\", <code>indices</code> = [1,0,2]\\n<strong>Output:</strong> \\"rat\\"\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>s.length == indices.length == n</code></li>\\n\\t<li><code>1 &lt;= n &lt;= 100</code></li>\\n\\t<li><code>s</code> contains only lower-case English letters.</li>\\n\\t<li><code>0 &lt;= indices[i] &lt;&nbsp;n</code></li>\\n\\t<li>All values of <code>indices</code> are unique (i.e. <code>indices</code> is a permutation of the integers from <code>0</code> to <code>n - 1</code>).</li>\\n</ul></div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    string restoreString(string s, vector<int> &indices)\\n    {\\n\\n        int n = s.length();\\n\\n        char arr[n+1];\\n        fill_n(arr, n+1, \'\\\\0\');\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            arr[indices[i]] = s[i];\\n        }        \\n        string res(arr);\\n        return res;\\n    }\\n};","number":"1528"},"1534":{"link":"https://leetcode.com/problems/count-good-triplets","name":"Count Good Triplets","difficulty":"Easy","statement":"<div><p>Given an array of integers <code>arr</code>, and three integers&nbsp;<code>a</code>,&nbsp;<code>b</code>&nbsp;and&nbsp;<code>c</code>. You need to find the number of good triplets.</p>\\n\\n<p>A triplet <code>(arr[i], arr[j], arr[k])</code>&nbsp;is <strong>good</strong> if the following conditions are true:</p>\\n\\n<ul>\\n\\t<li><code>0 &lt;= i &lt; j &lt; k &lt;&nbsp;arr.length</code></li>\\n\\t<li><code>|arr[i] - arr[j]| &lt;= a</code></li>\\n\\t<li><code>|arr[j] - arr[k]| &lt;= b</code></li>\\n\\t<li><code>|arr[i] - arr[k]| &lt;= c</code></li>\\n</ul>\\n\\n<p>Where <code>|x|</code> denotes the absolute value of <code>x</code>.</p>\\n\\n<p>Return<em> the number of good triplets</em>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\\n<strong>Output:</strong> 4\\n<strong>Explanation:</strong>&nbsp;There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [1,1,2,2,3], a = 0, b = 0, c = 1\\n<strong>Output:</strong> 0\\n<strong>Explanation: </strong>No triplet satisfies all conditions.\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>3 &lt;= arr.length &lt;= 100</code></li>\\n\\t<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>\\n\\t<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>\\n</ul></div>","language":"cpp","solution":"#include<iostream>\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\\n        int n = arr.size();\\n\\n        int count = 0;\\n\\n        for(int i= 0; i < n; i++) {\\n            for (int j = i+1; j < n; j++) {\\n                for (int k = j+1; k < n; k++) {\\n                    if ( abs(arr[i] - arr[j]) <= a && abs(arr[j]-arr[k]) <= b && abs(arr[i] - arr[k])<=c ) count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};","number":"1534"},"1572":{"link":"https://leetcode.com/problems/matrix-diagonal-sum","name":"Matrix Diagonal Sum","difficulty":"Easy","statement":"<div><p>Given a&nbsp;square&nbsp;matrix&nbsp;<code>mat</code>, return the sum of the matrix diagonals.</p>\\n\\n<p>Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n<img alt=\\"\\" src=\\"https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png\\" style=\\"width: 336px; height: 174px;\\">\\n<pre><strong>Input:</strong> mat = [[<strong>1</strong>,2,<strong>3</strong>],\\n&nbsp;             [4,<strong>5</strong>,6],\\n&nbsp;             [<strong>7</strong>,8,<strong>9</strong>]]\\n<strong>Output:</strong> 25\\n<strong>Explanation: </strong>Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25\\nNotice that element mat[1][1] = 5 is counted only once.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> mat = [[<strong>1</strong>,1,1,<strong>1</strong>],\\n&nbsp;             [1,<strong>1</strong>,<strong>1</strong>,1],\\n&nbsp;             [1,<strong>1</strong>,<strong>1</strong>,1],\\n&nbsp;             [<strong>1</strong>,1,1,<strong>1</strong>]]\\n<strong>Output:</strong> 8\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> mat = [[<strong>5</strong>]]\\n<strong>Output:</strong> 5\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>n == mat.length == mat[i].length</code></li>\\n\\t<li><code>1 &lt;= n &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int diagonalSum(vector<vector<int>> &mat)\\n    {\\n\\n        int n = mat.size();\\n        int sum = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            sum += mat[i][i];\\n            if (i != n-i-1) sum += mat[i][n-i-1];\\n        }\\n        return sum;\\n    }\\n};","number":"1572"},"1588":{"link":"https://leetcode.com/problems/sum-of-all-odd-length-subarrays","name":"Sum of All Odd Length Subarrays","difficulty":"Easy","statement":"<div><p>Given an array of positive integers&nbsp;<code>arr</code>, calculate the sum of all possible odd-length subarrays.</p>\\n\\n<p>A subarray is a contiguous&nbsp;subsequence of the array.</p>\\n\\n<p>Return&nbsp;<em>the sum of all odd-length subarrays of&nbsp;</em><code>arr</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [1,4,2,5,3]\\n<strong>Output:</strong> 58\\n<strong>Explanation: </strong>The odd-length subarrays of arr and their sums are:\\n[1] = 1\\n[4] = 4\\n[2] = 2\\n[5] = 5\\n[3] = 3\\n[1,4,2] = 7\\n[4,2,5] = 11\\n[2,5,3] = 10\\n[1,4,2,5,3] = 15\\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [1,2]\\n<strong>Output:</strong> 3\\n<b>Explanation: </b>There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> arr = [10,11,12]\\n<strong>Output:</strong> 66\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= arr.length &lt;= 100</code></li>\\n\\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int sumOddLengthSubarrays(vector<int> &arr)\\n    {\\n\\n        int n = arr.size();\\n\\n        int sum = 0;\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = i; j < n; j += 2)\\n            {\\n                for(int k = i; k <= j; k++) {\\n                    sum += arr[k];\\n                }\\n            }\\n        }\\n\\n        return sum;\\n    }\\n};","number":"1588"},"1603":{"link":"https://leetcode.com/problems/design-parking-system","name":"Design Parking System","difficulty":"Easy","statement":"<div><p>Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.</p>\\n\\n<p>Implement the <code>ParkingSystem</code> class:</p>\\n\\n<ul>\\n\\t<li><code>ParkingSystem(int big, int medium, int small)</code> Initializes object of the <code>ParkingSystem</code> class. The number of slots for each parking space are given as part of the constructor.</li>\\n\\t<li><code>bool addCar(int carType)</code> Checks whether there is a parking space of <code>carType</code> for the car that wants to get into the parking lot. <code>carType</code> can be of three kinds: big, medium, or small, which are represented by <code>1</code>, <code>2</code>, and <code>3</code> respectively. <strong>A car can only park in a parking space of its </strong><code>carType</code>. If there is no space available, return <code>false</code>, else park the car in that size space and return <code>true</code>.</li>\\n</ul>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input</strong>\\n[\\"ParkingSystem\\", \\"addCar\\", \\"addCar\\", \\"addCar\\", \\"addCar\\"]\\n[[1, 1, 0], [1], [2], [3], [1]]\\n<strong>Output</strong>\\n[null, true, true, false, false]\\n\\n<strong>Explanation</strong>\\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\\nparkingSystem.addCar(1); // return true because there is 1 available slot for a big car\\nparkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\\nparkingSystem.addCar(3); // return false because there is no available slot for a small car\\nparkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>0 &lt;= big, medium, small &lt;= 1000</code></li>\\n\\t<li><code>carType</code> is <code>1</code>, <code>2</code>, or <code>3</code></li>\\n\\t<li>At most <code>1000</code> calls will be made to <code>addCar</code></li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass ParkingSystem\\n{\\npublic:\\n    int b, s, m;\\n    int c_big, c_small, c_medium;\\n\\n    ParkingSystem(int big, int medium, int small)\\n    {\\n        b = 0;\\n        s = 0;\\n        m = 0;\\n        c_big = big;\\n        c_medium = medium;\\n        c_small = small;\\n    }\\n\\n    bool addCar(int carType)\\n    {\\n        switch (carType)\\n        {\\n        case 3:\\n            if (s < c_small)\\n            {\\n                ++s;\\n                cout << s;\\n                return true;\\n            }\\n            return false;\\n            break;\\n        case 2:\\n            if (m < c_medium)\\n            {\\n                ++m;\\n                cout << m;\\n                return true;\\n            }\\n            return false;\\n            break;\\n        case 1:\\n            if (b < c_big)\\n            {\\n                cout << b;\\n                ++b;\\n                return true;\\n            }\\n            return false;\\n            break;\\n        default:\\n            break;\\n        }\\n        return false;\\n    }\\n};","number":"1603"},"1614":{"link":"https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses","name":"Maximum Nesting Depth of the Parentheses","difficulty":"Easy","statement":"<div><p>A string is a <strong>valid parentheses string</strong> (denoted <strong>VPS</strong>) if it meets one of the following:</p>\\n\\n<ul>\\n\\t<li>It is an empty string <code>\\"\\"</code>, or a single character not equal to <code>\\"(\\"</code> or <code>\\")\\"</code>,</li>\\n\\t<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are <strong>VPS</strong>\'s, or</li>\\n\\t<li>It can be written as <code>(A)</code>, where <code>A</code> is a <strong>VPS</strong>.</li>\\n</ul>\\n\\n<p>We can similarly define the <strong>nesting depth</strong> <code>depth(S)</code> of any VPS <code>S</code> as follows:</p>\\n\\n<ul>\\n\\t<li><code>depth(\\"\\") = 0</code></li>\\n\\t<li><code>depth(A + B) = max(depth(A), depth(B))</code>, where <code>A</code> and <code>B</code> are <strong>VPS</strong>\'s</li>\\n\\t<li><code>depth(\\"(\\" + A + \\")\\") = 1 + depth(A)</code>, where <code>A</code> is a <strong>VPS</strong>.</li>\\n</ul>\\n\\n<p>For example, <code>\\"\\"</code>, <code>\\"()()\\"</code>, and <code>\\"()(()())\\"</code> are <strong>VPS</strong>\'s (with nesting depths 0, 1, and 2), and <code>\\")(\\"</code> and <code>\\"(()\\"</code> are not <strong>VPS</strong>\'s.</p>\\n\\n<p>Given a <strong>VPS</strong> represented as string <code>s</code>, return <em>the <strong>nesting depth</strong> of </em><code>s</code>.</p>\\n\\n<p>&nbsp;</p>\\n<p><strong>Example 1:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"(1+(2*3)+((<u>8</u>)/4))+1\\"\\n<strong>Output:</strong> 3\\n<strong>Explanation:</strong> Digit 8 is inside of 3 nested parentheses in the string.\\n</pre>\\n\\n<p><strong>Example 2:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"(1)+((2))+(((<u>3</u>)))\\"\\n<strong>Output:</strong> 3\\n</pre>\\n\\n<p><strong>Example 3:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"1+(<u>2</u>*3)/(2-1)\\"\\n<strong>Output:</strong> 1\\n</pre>\\n\\n<p><strong>Example 4:</strong></p>\\n\\n<pre><strong>Input:</strong> s = \\"<u>1</u>\\"\\n<strong>Output:</strong> 0\\n</pre>\\n\\n<p>&nbsp;</p>\\n<p><strong>Constraints:</strong></p>\\n\\n<ul>\\n\\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\\n\\t<li><code>s</code> consists of digits <code>0-9</code> and characters <code>\'+\'</code>, <code>\'-\'</code>, <code>\'*\'</code>, <code>\'/\'</code>, <code>\'(\'</code>, and <code>\')\'</code>.</li>\\n\\t<li>It is guaranteed that parentheses expression <code>s</code> is a <strong>VPS</strong>.</li>\\n</ul>\\n</div>","language":"cpp","solution":"#include <iostream>\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nclass Solution\\n{\\npublic:\\n    int maxDepth(string s)\\n    {\\n\\n        int max_depth = 0;\\n        int current_depth = 0;\\n\\n        for (char ch : s)\\n        {\\n            if (ch == \'(\')\\n                ++current_depth;\\n            else if (ch == \')\')\\n                --current_depth;\\n            max_depth = max_depth > current_depth ? max_depth : current_depth;\\n        }\\n\\n        return max_depth;\\n    }\\n};","number":"1614"}}')},82:function(n,e,t){var s={"./Binary_Property/ASCII.js":83,"./Binary_Property/ASCII_Hex_Digit.js":84,"./Binary_Property/Alphabetic.js":85,"./Binary_Property/Any.js":86,"./Binary_Property/Assigned.js":87,"./Binary_Property/Bidi_Control.js":88,"./Binary_Property/Bidi_Mirrored.js":89,"./Binary_Property/Case_Ignorable.js":90,"./Binary_Property/Cased.js":91,"./Binary_Property/Changes_When_Casefolded.js":92,"./Binary_Property/Changes_When_Casemapped.js":93,"./Binary_Property/Changes_When_Lowercased.js":94,"./Binary_Property/Changes_When_NFKC_Casefolded.js":95,"./Binary_Property/Changes_When_Titlecased.js":96,"./Binary_Property/Changes_When_Uppercased.js":97,"./Binary_Property/Dash.js":98,"./Binary_Property/Default_Ignorable_Code_Point.js":99,"./Binary_Property/Deprecated.js":100,"./Binary_Property/Diacritic.js":101,"./Binary_Property/Emoji.js":102,"./Binary_Property/Emoji_Component.js":103,"./Binary_Property/Emoji_Modifier.js":104,"./Binary_Property/Emoji_Modifier_Base.js":105,"./Binary_Property/Emoji_Presentation.js":106,"./Binary_Property/Extended_Pictographic.js":107,"./Binary_Property/Extender.js":108,"./Binary_Property/Grapheme_Base.js":109,"./Binary_Property/Grapheme_Extend.js":110,"./Binary_Property/Hex_Digit.js":111,"./Binary_Property/IDS_Binary_Operator.js":112,"./Binary_Property/IDS_Trinary_Operator.js":113,"./Binary_Property/ID_Continue.js":114,"./Binary_Property/ID_Start.js":115,"./Binary_Property/Ideographic.js":116,"./Binary_Property/Join_Control.js":117,"./Binary_Property/Logical_Order_Exception.js":118,"./Binary_Property/Lowercase.js":119,"./Binary_Property/Math.js":120,"./Binary_Property/Noncharacter_Code_Point.js":121,"./Binary_Property/Pattern_Syntax.js":122,"./Binary_Property/Pattern_White_Space.js":123,"./Binary_Property/Quotation_Mark.js":124,"./Binary_Property/Radical.js":125,"./Binary_Property/Regional_Indicator.js":126,"./Binary_Property/Sentence_Terminal.js":127,"./Binary_Property/Soft_Dotted.js":128,"./Binary_Property/Terminal_Punctuation.js":129,"./Binary_Property/Unified_Ideograph.js":130,"./Binary_Property/Uppercase.js":131,"./Binary_Property/Variation_Selector.js":132,"./Binary_Property/White_Space.js":133,"./Binary_Property/XID_Continue.js":134,"./Binary_Property/XID_Start.js":135,"./General_Category/Cased_Letter.js":136,"./General_Category/Close_Punctuation.js":137,"./General_Category/Connector_Punctuation.js":138,"./General_Category/Control.js":139,"./General_Category/Currency_Symbol.js":140,"./General_Category/Dash_Punctuation.js":141,"./General_Category/Decimal_Number.js":142,"./General_Category/Enclosing_Mark.js":143,"./General_Category/Final_Punctuation.js":144,"./General_Category/Format.js":145,"./General_Category/Initial_Punctuation.js":146,"./General_Category/Letter.js":147,"./General_Category/Letter_Number.js":148,"./General_Category/Line_Separator.js":149,"./General_Category/Lowercase_Letter.js":150,"./General_Category/Mark.js":151,"./General_Category/Math_Symbol.js":152,"./General_Category/Modifier_Letter.js":153,"./General_Category/Modifier_Symbol.js":154,"./General_Category/Nonspacing_Mark.js":155,"./General_Category/Number.js":156,"./General_Category/Open_Punctuation.js":157,"./General_Category/Other.js":158,"./General_Category/Other_Letter.js":159,"./General_Category/Other_Number.js":160,"./General_Category/Other_Punctuation.js":161,"./General_Category/Other_Symbol.js":162,"./General_Category/Paragraph_Separator.js":163,"./General_Category/Private_Use.js":164,"./General_Category/Punctuation.js":165,"./General_Category/Separator.js":166,"./General_Category/Space_Separator.js":167,"./General_Category/Spacing_Mark.js":168,"./General_Category/Surrogate.js":169,"./General_Category/Symbol.js":170,"./General_Category/Titlecase_Letter.js":171,"./General_Category/Unassigned.js":172,"./General_Category/Uppercase_Letter.js":173,"./Script/Adlam.js":174,"./Script/Ahom.js":175,"./Script/Anatolian_Hieroglyphs.js":176,"./Script/Arabic.js":177,"./Script/Armenian.js":178,"./Script/Avestan.js":179,"./Script/Balinese.js":180,"./Script/Bamum.js":181,"./Script/Bassa_Vah.js":182,"./Script/Batak.js":183,"./Script/Bengali.js":184,"./Script/Bhaiksuki.js":185,"./Script/Bopomofo.js":186,"./Script/Brahmi.js":187,"./Script/Braille.js":188,"./Script/Buginese.js":189,"./Script/Buhid.js":190,"./Script/Canadian_Aboriginal.js":191,"./Script/Carian.js":192,"./Script/Caucasian_Albanian.js":193,"./Script/Chakma.js":194,"./Script/Cham.js":195,"./Script/Cherokee.js":196,"./Script/Chorasmian.js":197,"./Script/Common.js":198,"./Script/Coptic.js":199,"./Script/Cuneiform.js":200,"./Script/Cypriot.js":201,"./Script/Cyrillic.js":202,"./Script/Deseret.js":203,"./Script/Devanagari.js":204,"./Script/Dives_Akuru.js":205,"./Script/Dogra.js":206,"./Script/Duployan.js":207,"./Script/Egyptian_Hieroglyphs.js":208,"./Script/Elbasan.js":209,"./Script/Elymaic.js":210,"./Script/Ethiopic.js":211,"./Script/Georgian.js":212,"./Script/Glagolitic.js":213,"./Script/Gothic.js":214,"./Script/Grantha.js":215,"./Script/Greek.js":216,"./Script/Gujarati.js":217,"./Script/Gunjala_Gondi.js":218,"./Script/Gurmukhi.js":219,"./Script/Han.js":220,"./Script/Hangul.js":221,"./Script/Hanifi_Rohingya.js":222,"./Script/Hanunoo.js":223,"./Script/Hatran.js":224,"./Script/Hebrew.js":225,"./Script/Hiragana.js":226,"./Script/Imperial_Aramaic.js":227,"./Script/Inherited.js":228,"./Script/Inscriptional_Pahlavi.js":229,"./Script/Inscriptional_Parthian.js":230,"./Script/Javanese.js":231,"./Script/Kaithi.js":232,"./Script/Kannada.js":233,"./Script/Katakana.js":234,"./Script/Kayah_Li.js":235,"./Script/Kharoshthi.js":236,"./Script/Khitan_Small_Script.js":237,"./Script/Khmer.js":238,"./Script/Khojki.js":239,"./Script/Khudawadi.js":240,"./Script/Lao.js":241,"./Script/Latin.js":242,"./Script/Lepcha.js":243,"./Script/Limbu.js":244,"./Script/Linear_A.js":245,"./Script/Linear_B.js":246,"./Script/Lisu.js":247,"./Script/Lycian.js":248,"./Script/Lydian.js":249,"./Script/Mahajani.js":250,"./Script/Makasar.js":251,"./Script/Malayalam.js":252,"./Script/Mandaic.js":253,"./Script/Manichaean.js":254,"./Script/Marchen.js":255,"./Script/Masaram_Gondi.js":256,"./Script/Medefaidrin.js":257,"./Script/Meetei_Mayek.js":258,"./Script/Mende_Kikakui.js":259,"./Script/Meroitic_Cursive.js":260,"./Script/Meroitic_Hieroglyphs.js":261,"./Script/Miao.js":262,"./Script/Modi.js":263,"./Script/Mongolian.js":264,"./Script/Mro.js":265,"./Script/Multani.js":266,"./Script/Myanmar.js":267,"./Script/Nabataean.js":268,"./Script/Nandinagari.js":269,"./Script/New_Tai_Lue.js":270,"./Script/Newa.js":271,"./Script/Nko.js":272,"./Script/Nushu.js":273,"./Script/Nyiakeng_Puachue_Hmong.js":274,"./Script/Ogham.js":275,"./Script/Ol_Chiki.js":276,"./Script/Old_Hungarian.js":277,"./Script/Old_Italic.js":278,"./Script/Old_North_Arabian.js":279,"./Script/Old_Permic.js":280,"./Script/Old_Persian.js":281,"./Script/Old_Sogdian.js":282,"./Script/Old_South_Arabian.js":283,"./Script/Old_Turkic.js":284,"./Script/Oriya.js":285,"./Script/Osage.js":286,"./Script/Osmanya.js":287,"./Script/Pahawh_Hmong.js":288,"./Script/Palmyrene.js":289,"./Script/Pau_Cin_Hau.js":290,"./Script/Phags_Pa.js":291,"./Script/Phoenician.js":292,"./Script/Psalter_Pahlavi.js":293,"./Script/Rejang.js":294,"./Script/Runic.js":295,"./Script/Samaritan.js":296,"./Script/Saurashtra.js":297,"./Script/Sharada.js":298,"./Script/Shavian.js":299,"./Script/Siddham.js":300,"./Script/SignWriting.js":301,"./Script/Sinhala.js":302,"./Script/Sogdian.js":303,"./Script/Sora_Sompeng.js":304,"./Script/Soyombo.js":305,"./Script/Sundanese.js":306,"./Script/Syloti_Nagri.js":307,"./Script/Syriac.js":308,"./Script/Tagalog.js":309,"./Script/Tagbanwa.js":310,"./Script/Tai_Le.js":311,"./Script/Tai_Tham.js":312,"./Script/Tai_Viet.js":313,"./Script/Takri.js":314,"./Script/Tamil.js":315,"./Script/Tangut.js":316,"./Script/Telugu.js":317,"./Script/Thaana.js":318,"./Script/Thai.js":319,"./Script/Tibetan.js":320,"./Script/Tifinagh.js":321,"./Script/Tirhuta.js":322,"./Script/Ugaritic.js":323,"./Script/Vai.js":324,"./Script/Wancho.js":325,"./Script/Warang_Citi.js":326,"./Script/Yezidi.js":327,"./Script/Yi.js":328,"./Script/Zanabazar_Square.js":329,"./Script_Extensions/Adlam.js":330,"./Script_Extensions/Ahom.js":331,"./Script_Extensions/Anatolian_Hieroglyphs.js":332,"./Script_Extensions/Arabic.js":333,"./Script_Extensions/Armenian.js":334,"./Script_Extensions/Avestan.js":335,"./Script_Extensions/Balinese.js":336,"./Script_Extensions/Bamum.js":337,"./Script_Extensions/Bassa_Vah.js":338,"./Script_Extensions/Batak.js":339,"./Script_Extensions/Bengali.js":340,"./Script_Extensions/Bhaiksuki.js":341,"./Script_Extensions/Bopomofo.js":342,"./Script_Extensions/Brahmi.js":343,"./Script_Extensions/Braille.js":344,"./Script_Extensions/Buginese.js":345,"./Script_Extensions/Buhid.js":346,"./Script_Extensions/Canadian_Aboriginal.js":347,"./Script_Extensions/Carian.js":348,"./Script_Extensions/Caucasian_Albanian.js":349,"./Script_Extensions/Chakma.js":350,"./Script_Extensions/Cham.js":351,"./Script_Extensions/Cherokee.js":352,"./Script_Extensions/Chorasmian.js":353,"./Script_Extensions/Common.js":354,"./Script_Extensions/Coptic.js":355,"./Script_Extensions/Cuneiform.js":356,"./Script_Extensions/Cypriot.js":357,"./Script_Extensions/Cyrillic.js":358,"./Script_Extensions/Deseret.js":359,"./Script_Extensions/Devanagari.js":360,"./Script_Extensions/Dives_Akuru.js":361,"./Script_Extensions/Dogra.js":362,"./Script_Extensions/Duployan.js":363,"./Script_Extensions/Egyptian_Hieroglyphs.js":364,"./Script_Extensions/Elbasan.js":365,"./Script_Extensions/Elymaic.js":366,"./Script_Extensions/Ethiopic.js":367,"./Script_Extensions/Georgian.js":368,"./Script_Extensions/Glagolitic.js":369,"./Script_Extensions/Gothic.js":370,"./Script_Extensions/Grantha.js":371,"./Script_Extensions/Greek.js":372,"./Script_Extensions/Gujarati.js":373,"./Script_Extensions/Gunjala_Gondi.js":374,"./Script_Extensions/Gurmukhi.js":375,"./Script_Extensions/Han.js":376,"./Script_Extensions/Hangul.js":377,"./Script_Extensions/Hanifi_Rohingya.js":378,"./Script_Extensions/Hanunoo.js":379,"./Script_Extensions/Hatran.js":380,"./Script_Extensions/Hebrew.js":381,"./Script_Extensions/Hiragana.js":382,"./Script_Extensions/Imperial_Aramaic.js":383,"./Script_Extensions/Inherited.js":384,"./Script_Extensions/Inscriptional_Pahlavi.js":385,"./Script_Extensions/Inscriptional_Parthian.js":386,"./Script_Extensions/Javanese.js":387,"./Script_Extensions/Kaithi.js":388,"./Script_Extensions/Kannada.js":389,"./Script_Extensions/Katakana.js":390,"./Script_Extensions/Kayah_Li.js":391,"./Script_Extensions/Kharoshthi.js":392,"./Script_Extensions/Khitan_Small_Script.js":393,"./Script_Extensions/Khmer.js":394,"./Script_Extensions/Khojki.js":395,"./Script_Extensions/Khudawadi.js":396,"./Script_Extensions/Lao.js":397,"./Script_Extensions/Latin.js":398,"./Script_Extensions/Lepcha.js":399,"./Script_Extensions/Limbu.js":400,"./Script_Extensions/Linear_A.js":401,"./Script_Extensions/Linear_B.js":402,"./Script_Extensions/Lisu.js":403,"./Script_Extensions/Lycian.js":404,"./Script_Extensions/Lydian.js":405,"./Script_Extensions/Mahajani.js":406,"./Script_Extensions/Makasar.js":407,"./Script_Extensions/Malayalam.js":408,"./Script_Extensions/Mandaic.js":409,"./Script_Extensions/Manichaean.js":410,"./Script_Extensions/Marchen.js":411,"./Script_Extensions/Masaram_Gondi.js":412,"./Script_Extensions/Medefaidrin.js":413,"./Script_Extensions/Meetei_Mayek.js":414,"./Script_Extensions/Mende_Kikakui.js":415,"./Script_Extensions/Meroitic_Cursive.js":416,"./Script_Extensions/Meroitic_Hieroglyphs.js":417,"./Script_Extensions/Miao.js":418,"./Script_Extensions/Modi.js":419,"./Script_Extensions/Mongolian.js":420,"./Script_Extensions/Mro.js":421,"./Script_Extensions/Multani.js":422,"./Script_Extensions/Myanmar.js":423,"./Script_Extensions/Nabataean.js":424,"./Script_Extensions/Nandinagari.js":425,"./Script_Extensions/New_Tai_Lue.js":426,"./Script_Extensions/Newa.js":427,"./Script_Extensions/Nko.js":428,"./Script_Extensions/Nushu.js":429,"./Script_Extensions/Nyiakeng_Puachue_Hmong.js":430,"./Script_Extensions/Ogham.js":431,"./Script_Extensions/Ol_Chiki.js":432,"./Script_Extensions/Old_Hungarian.js":433,"./Script_Extensions/Old_Italic.js":434,"./Script_Extensions/Old_North_Arabian.js":435,"./Script_Extensions/Old_Permic.js":436,"./Script_Extensions/Old_Persian.js":437,"./Script_Extensions/Old_Sogdian.js":438,"./Script_Extensions/Old_South_Arabian.js":439,"./Script_Extensions/Old_Turkic.js":440,"./Script_Extensions/Oriya.js":441,"./Script_Extensions/Osage.js":442,"./Script_Extensions/Osmanya.js":443,"./Script_Extensions/Pahawh_Hmong.js":444,"./Script_Extensions/Palmyrene.js":445,"./Script_Extensions/Pau_Cin_Hau.js":446,"./Script_Extensions/Phags_Pa.js":447,"./Script_Extensions/Phoenician.js":448,"./Script_Extensions/Psalter_Pahlavi.js":449,"./Script_Extensions/Rejang.js":450,"./Script_Extensions/Runic.js":451,"./Script_Extensions/Samaritan.js":452,"./Script_Extensions/Saurashtra.js":453,"./Script_Extensions/Sharada.js":454,"./Script_Extensions/Shavian.js":455,"./Script_Extensions/Siddham.js":456,"./Script_Extensions/SignWriting.js":457,"./Script_Extensions/Sinhala.js":458,"./Script_Extensions/Sogdian.js":459,"./Script_Extensions/Sora_Sompeng.js":460,"./Script_Extensions/Soyombo.js":461,"./Script_Extensions/Sundanese.js":462,"./Script_Extensions/Syloti_Nagri.js":463,"./Script_Extensions/Syriac.js":464,"./Script_Extensions/Tagalog.js":465,"./Script_Extensions/Tagbanwa.js":466,"./Script_Extensions/Tai_Le.js":467,"./Script_Extensions/Tai_Tham.js":468,"./Script_Extensions/Tai_Viet.js":469,"./Script_Extensions/Takri.js":470,"./Script_Extensions/Tamil.js":471,"./Script_Extensions/Tangut.js":472,"./Script_Extensions/Telugu.js":473,"./Script_Extensions/Thaana.js":474,"./Script_Extensions/Thai.js":475,"./Script_Extensions/Tibetan.js":476,"./Script_Extensions/Tifinagh.js":477,"./Script_Extensions/Tirhuta.js":478,"./Script_Extensions/Ugaritic.js":479,"./Script_Extensions/Vai.js":480,"./Script_Extensions/Wancho.js":481,"./Script_Extensions/Warang_Citi.js":482,"./Script_Extensions/Yezidi.js":483,"./Script_Extensions/Yi.js":484,"./Script_Extensions/Zanabazar_Square.js":485,"./index.js":486,"./unicode-version.js":487};function r(n){var e=o(n);return t(e)}function o(n){if(!t.o(s,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return s[n]}r.keys=function(){return Object.keys(s)},r.resolve=o,n.exports=r,r.id=82}},[[44,1,2]]]);
//# sourceMappingURL=main.6d289f42.chunk.js.map