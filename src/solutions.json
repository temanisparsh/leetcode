{"897": {"link": "https://leetcode.com/problems/increasing-order-search-tree", "name": "Increasing Order Search Tree", "difficulty": "Easy", "statement": "<div><p>Given a binary search tree, rearrange the tree in <strong>in-order</strong> so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>\n\n<pre><strong>Example 1:</strong>\n<strong>Input:</strong> [5,3,6,2,4,null,8,1,null,null,null,7,9]\n\n       5\n      / \\\n    3    6\n   / \\    \\\n  2   4    8\n&nbsp;/        / \\ \n1        7   9\n\n<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n\n 1\n&nbsp; \\\n&nbsp;  2\n&nbsp;   \\\n&nbsp;    3\n&nbsp;     \\\n&nbsp;      4\n&nbsp;       \\\n&nbsp;        5\n&nbsp;         \\\n&nbsp;          6\n&nbsp;           \\\n&nbsp;            7\n&nbsp;             \\\n&nbsp;              8\n&nbsp;               \\\n                 9  </pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the given tree will be between <code>1</code> and <code>100</code>.</li>\n\t<li>Each node will have a unique integer value from <code>0</code> to <code>1000</code>.</li>\n</ul>\n</div>", "language": "c", "solution": "#include<stdio.h>\n\nstruct TreeNode\n{\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n\nstruct TreeNode *increasingBST(struct TreeNode *root)\n{\n    struct TreeNode *middle = (struct TreeNode *)malloc(sizeof(struct TreeNode));\n    middle->right = NULL;\n    middle->left = NULL;\n    middle->val = root->val;\n\n    struct TreeNode *left;\n\n    if (root->left)\n    {\n        left = increasingBST(root->left);\n        struct TreeNode *temp = left;\n        while (temp->right)\n        {\n            temp = temp->right;\n        }\n        temp->right = middle;\n    }\n\n    if (root->right)\n    {\n        middle->right = increasingBST(root->right);\n    }\n    return root->left ? left : middle;\n}", "number": "897"}, "961": {"link": "https://leetcode.com/problems/n-repeated-element-in-size-2n-array", "name": "N-Repeated Element in Size 2N Array", "difficulty": "Easy", "statement": "<div><p>In a array <code>A</code> of size <code>2N</code>, there are <code>N+1</code> unique elements, and exactly one of these elements is repeated <code>N</code> times.</p>\n\n<p>Return the element repeated <code>N</code> times.</p>\n\n<p>&nbsp;</p>\n\n<ol>\n</ol>\n\n<div>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-1-1\">[1,2,3,3]</span>\n<strong>Output: </strong><span id=\"example-output-1\">3</span>\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-2-1\">[2,1,2,5,3,2]</span>\n<strong>Output: </strong><span id=\"example-output-2\">2</span>\n</pre>\n\n<div>\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-3-1\">[5,1,5,2,5,3,5,4]</span>\n<strong>Output: </strong><span id=\"example-output-3\">5</span>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li><code>4 &lt;= A.length &lt;= 10000</code></li>\n\t<li><code>0 &lt;= A[i] &lt; 10000</code></li>\n\t<li><code>A.length</code> is even</li>\n</ul>\n</div>\n</div>\n</div>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int repeatedNTimes(vector<int>& A) {\n\n        int v[100001];\n        fill_n(v, 100001, 0);\n        for(int i: A) if (v[i]++) return i;\n\n    }\n};", "number": "961"}, "557": {"link": "https://leetcode.com/problems/reverse-words-in-a-string-iii", "name": "Reverse Words in a String III", "difficulty": "Easy", "statement": "<div><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \"Let's take LeetCode contest\"\n<b>Output:</b> \"s'teL ekat edoCteeL tsetnoc\"\n</pre>\n<p></p>\n\n<p><b>Note:</b>\nIn the string, each word is separated by single space and there will not be any extra space in the string.\n</p></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string reverseWords(string s) {\n\n        vector<int> ind;\n        ind.push_back(-1);\n        int n = s.length();\n\n        for(int i = 0; i < n; i++) {\n            if (s[i] == ' ') {\n                ind.push_back(i);\n            }\n        }\n\n        ind.push_back(n);\n\n        stringstream res;\n\n        int nums = ind.size();\n        for(int i = 0; i < nums - 1; i++) {\n            for(int j = ind[i + 1] - 1; j > ind[i]; j--) {\n                res << s[j];\n            }\n            if (i < nums - 2) {\n                res << ' ';\n            }\n        }\n\n        return res.str();\n    }\n};", "number": "557"}, "1528": {"link": "https://leetcode.com/problems/shuffle-string", "name": "Shuffle String", "difficulty": "Easy", "statement": "<div><p>Given a string <code>s</code>&nbsp;and an integer array <code>indices</code> of the <strong>same length</strong>.</p>\n\n<p>The string <code>s</code> will be shuffled such that the character at the <code>i<sup>th</sup></code> position moves to&nbsp;<code>indices[i]</code> in the shuffled string.</p>\n\n<p>Return <em>the shuffled string</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/07/09/q1.jpg\" style=\"width: 321px; height: 243px;\">\n<pre><strong>Input:</strong> s = \"codeleet\", <code>indices</code> = [4,5,6,7,0,2,1,3]\n<strong>Output:</strong> \"leetcode\"\n<strong>Explanation:</strong> As shown, \"codeleet\" becomes \"leetcode\" after shuffling.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> s = \"abc\", <code>indices</code> = [0,1,2]\n<strong>Output:</strong> \"abc\"\n<strong>Explanation:</strong> After shuffling, each character remains in its position.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> s = \"aiohn\", <code>indices</code> = [3,1,4,2,0]\n<strong>Output:</strong> \"nihao\"\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><strong>Input:</strong> s = \"aaiougrt\", <code>indices</code> = [4,0,2,6,7,3,1,5]\n<strong>Output:</strong> \"arigatou\"\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre><strong>Input:</strong> s = \"art\", <code>indices</code> = [1,0,2]\n<strong>Output:</strong> \"rat\"\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>s.length == indices.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>s</code> contains only lower-case English letters.</li>\n\t<li><code>0 &lt;= indices[i] &lt;&nbsp;n</code></li>\n\t<li>All values of <code>indices</code> are unique (i.e. <code>indices</code> is a permutation of the integers from <code>0</code> to <code>n - 1</code>).</li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    string restoreString(string s, vector<int> &indices)\n    {\n\n        int n = s.length();\n\n        char arr[n+1];\n        fill_n(arr, n+1, '\\0');\n        \n        for (int i = 0; i < n; i++)\n        {\n            arr[indices[i]] = s[i];\n        }        \n        string res(arr);\n        return res;\n    }\n};", "number": "1528"}, "1365": {"link": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number", "name": "How Many Numbers Are Smaller Than the Current Number", "difficulty": "Easy", "statement": "<div><p>Given the array <code>nums</code>, for each <code>nums[i]</code> find out how many numbers in the array are smaller than it. That is, for each <code>nums[i]</code> you have to count the number of valid <code>j's</code>&nbsp;such that&nbsp;<code>j != i</code> <strong>and</strong> <code>nums[j] &lt; nums[i]</code>.</p>\n\n<p>Return the answer in an array.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [8,1,2,2,3]\n<strong>Output:</strong> [4,0,1,1,3]\n<strong>Explanation:</strong> \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [6,5,4,8]\n<strong>Output:</strong> [2,1,0,3]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> nums = [7,7,7,7]\n<strong>Output:</strong> [0,0,0,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    vector<int> smallerNumbersThanCurrent(vector<int> &nums)\n    {\n\n        vector<int> temp = nums;\n\n        sort(temp.begin(), temp.end());\n\n        int first_pos[101];\n        fill_n(first_pos, 101, -1);\n\n        int n = temp.size();\n\n        for (int i = 0; i < n; i++) {\n            if (first_pos[temp[i]] == -1) {\n                first_pos[temp[i]] = i;\n            }\n        }\n\n        vector<int> res;\n\n        for (int i = 0; i < n; i++) {\n            res.push_back(first_pos[nums[i]]);\n        }\n\n        return res;\n\n\n    }\n};", "number": "1365"}, "1502": {"link": "https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence", "name": "Can Make Arithmetic Progression From Sequence", "difficulty": "Easy", "statement": "<div><p>Given an array of numbers <code>arr</code>.&nbsp;A sequence of numbers is called an arithmetic progression&nbsp;if the difference between any two consecutive elements is the same.</p>\n\n<p>Return <code>true</code>&nbsp;if the array can be rearranged to form an arithmetic progression, otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> arr = [3,5,1]\n<strong>Output:</strong> true\n<strong>Explanation: </strong>We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> arr = [1,2,4]\n<strong>Output:</strong> false\n<strong>Explanation: </strong>There is no way to reorder the elements to obtain an arithmetic progression.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 1000</code></li>\n\t<li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    bool canMakeArithmeticProgression(vector<int> &arr)\n    {\n        sort(arr.begin(), arr.end());\n        int diff;\n        if (arr.size() > 1)\n            diff = arr[1] - arr[0];\n        for (int i = 0; i < arr.size() - 1; i++)\n        {\n            if (diff != arr[i + 1] - arr[i])\n                return false;\n        }\n        return true;\n    }\n};", "number": "1502"}, "832": {"link": "https://leetcode.com/problems/flipping-an-image", "name": "Flipping an Image", "difficulty": "Easy", "statement": "<div><p>Given a binary matrix <code>A</code>, we want to flip the image horizontally, then invert it, and return the resulting image.</p>\n\n<p>To flip an image horizontally means that each row of the image is reversed.&nbsp; For example, flipping&nbsp;<code>[1, 1, 0]</code>&nbsp;horizontally results in&nbsp;<code>[0, 1, 1]</code>.</p>\n\n<p>To invert an image means&nbsp;that each <code>0</code> is replaced by <code>1</code>, and each <code>1</code> is replaced by <code>0</code>.&nbsp;For example, inverting&nbsp;<code>[0, 1, 1]</code>&nbsp;results in&nbsp;<code>[1, 0, 0]</code>.</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input: </strong>[[1,1,0],[1,0,1],[0,0,0]]\n<strong>Output: </strong>[[1,0,0],[0,1,0],[1,1,1]]\n<strong>Explanation:</strong> First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\nThen, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input: </strong>[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\n<strong>Output: </strong>[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n<strong>Explanation:</strong> First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\nThen invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n</pre>\n\n<p><strong>Notes:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>\n\t<li><code>0 &lt;= A[i][j]<font face=\"sans-serif, Arial, Verdana, Trebuchet MS\">&nbsp;&lt;=&nbsp;</font>1</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& A) {\n\n        int n = A.size();\n\n        vector<vector<int>> res;\n\n        for (vector<int> a: A) {\n            vector<int> temp;\n            for(int x: a) {\n                temp.push_back(1-x);\n            }\n            reverse(temp.begin(), temp.end());\n            res.push_back(temp);\n        }\n\n        return res;\n        \n    }\n};", "number": "832"}, "1370": {"link": "https://leetcode.com/problems/increasing-decreasing-string", "name": "Increasing Decreasing String", "difficulty": "Easy", "statement": "<div><p>Given a string <code>s</code>. You should re-order the string using the following algorithm:</p>\n\n<ol>\n\t<li>Pick the <strong>smallest</strong> character from <code>s</code> and <strong>append</strong> it to the result.</li>\n\t<li>Pick the <strong>smallest</strong> character from <code>s</code> which is greater than the last appended character to the result and <strong>append</strong> it.</li>\n\t<li>Repeat step 2 until you cannot pick more characters.</li>\n\t<li>Pick the <strong>largest</strong>&nbsp;character from <code>s</code> and <strong>append</strong> it to the result.</li>\n\t<li>Pick the <strong>largest</strong>&nbsp;character from <code>s</code> which is smaller than the last appended character to the result and <strong>append</strong> it.</li>\n\t<li>Repeat step 5 until you cannot pick more characters.</li>\n\t<li>Repeat the steps from 1 to 6 until you pick all characters from <code>s</code>.</li>\n</ol>\n\n<p>In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.</p>\n\n<p>Return <em>the result string</em> after sorting <code>s</code>&nbsp;with this algorithm.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> s = \"aaaabbbbcccc\"\n<strong>Output:</strong> \"abccbaabccba\"\n<strong>Explanation:</strong> After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> s = \"rat\"\n<strong>Output:</strong> \"art\"\n<strong>Explanation:</strong> The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> s = \"leetcode\"\n<strong>Output:</strong> \"cdelotee\"\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><strong>Input:</strong> s = \"ggggggg\"\n<strong>Output:</strong> \"ggggggg\"\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre><strong>Input:</strong> s = \"spo\"\n<strong>Output:</strong> \"ops\"\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 500</code></li>\n\t<li><code>s</code> contains only lower-case English letters.</li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string sortString(string s) {\n\n        int n = s.length();\n\n        int count[26];\n        fill_n(count, 26, 0);\n\n        stringstream ss;\n\n        for(char i: s) {\n            ++count[(int)(i) - 97];\n        }\n\n        int max_count = -1;\n        for(int i: count) {\n            max_count = max_count > i ? max_count : i;\n        }\n\n        for (int step = 1; step <= max_count; ++step ) {\n\n            for (int i = 0; i < 26; i++) {\n                if (count[i] >= step) {\n                    ss << (char)(i + 97);\n                }\n            }\n\n            ++step;\n\n            for (int i = 25; i >= 0; i--) {\n                if (count[i] >= step) {\n                    ss << (char)(i + 97);\n                }\n            }\n\n        }\n\n        return ss.str();\n\n    }\n};", "number": "1370"}, "771": {"link": "https://leetcode.com/problems/jewels-and-stones", "name": "Jewels and Stones", "difficulty": "Easy", "statement": "<div><p>You're given strings <code>J</code> representing the types of stones that are jewels, and <code>S</code> representing the stones you have.&nbsp; Each character in <code>S</code> is a type of stone you have.&nbsp; You want to know how many of the stones you have are also jewels.</p>\n\n<p>The letters in <code>J</code> are guaranteed distinct, and all characters in <code>J</code> and <code>S</code> are letters. Letters are case sensitive, so <code>\"a\"</code> is considered a different type of stone from <code>\"A\"</code>.</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> J = \"aA\", S = \"aAAbbbb\"\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> J = \"z\", S = \"ZZ\"\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li><code>S</code> and <code>J</code> will consist of letters and have length at most 50.</li>\n\t<li>The characters in <code>J</code> are distinct.</li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int numJewelsInStones(string J, string S)\n    {\n\n        int isJewel[126];\n\n        fill_n(isJewel, 126, 0);\n\n        for (char i : J)\n        {\n            isJewel[(int)i] = 1;\n        }\n\n        int count = 0;\n        for (char i : S)\n        {\n            count += isJewel[(int)i];\n        }\n\n        return count;\n    }\n};", "number": "771"}, "709": {"link": "https://leetcode.com/problems/to-lower-case", "name": "To Lower Case", "difficulty": "Easy", "statement": "<div><p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.</p>\n\n<p>&nbsp;</p>\n\n<div>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-1-1\">\"Hello\"</span>\n<strong>Output: </strong><span id=\"example-output-1\">\"hello\"</span>\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-2-1\">\"here\"</span>\n<strong>Output: </strong><span id=\"example-output-2\">\"here\"</span>\n</pre>\n\n<div>\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-3-1\">\"LOVELY\"</span>\n<strong>Output: </strong><span id=\"example-output-3\">\"lovely\"</span>\n</pre>\n</div>\n</div>\n</div></div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string toLowerCase(string str) {\n\n        transform(str.begin(), str.end(), str.begin(), ::tolower);\n\n        return str;\n        \n    }\n};", "number": "709"}, "1464": {"link": "https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array", "name": "Maximum Product of Two Elements in an Array", "difficulty": "Easy", "statement": "<div>Given the array of integers <code>nums</code>, you will choose two different indices <code>i</code> and <code>j</code> of that array. <em>Return the maximum value of</em> <code>(nums[i]-1)*(nums[j]-1)</code>.\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [3,4,5,2]\n<strong>Output:</strong> 12 \n<strong>Explanation:</strong> If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. \n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,5,4,5]\n<strong>Output:</strong> 16\n<strong>Explanation:</strong> Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> nums = [3,7]\n<strong>Output:</strong> 12\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n\n        sort(nums.begin(), nums.end());      \n        int n = nums.size();\n\n        return (nums[n-1]-1)*(nums[n-2]-1);\n    }\n};", "number": "1464"}, "1475": {"link": "https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop", "name": "Final Prices With a Special Discount in a Shop", "difficulty": "Easy", "statement": "<div><p>Given the array <code>prices</code> where <code>prices[i]</code> is the price of the <code>ith</code> item in a shop. There is a special discount for items in the shop, if you buy the <code>ith</code> item, then you will receive a discount equivalent to <code>prices[j]</code> where <code>j</code> is the <strong>minimum</strong>&nbsp;index such that <code>j &gt; i</code> and <code>prices[j] &lt;= prices[i]</code>, otherwise, you will not receive any discount at all.</p>\n\n<p><em>Return an array where the <code>ith</code> element is the final price you will pay for the <code>ith</code> item of the shop considering the special discount.</em></p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> prices = [8,4,6,2,3]\n<strong>Output:</strong> [4,2,4,2,3]\n<strong>Explanation:</strong>&nbsp;\nFor item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.&nbsp;\nFor item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.&nbsp;\nFor item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.&nbsp;\nFor items 3 and 4 you will not receive any discount at all.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> [1,2,3,4,5]\n<strong>Explanation:</strong> In this case, for all items, you will not receive any discount at all.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> prices = [10,1,1,6]\n<strong>Output:</strong> [9,0,1,6]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 10^3</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    vector<int> finalPrices(vector<int> &prices)\n    {\n\n        int n = prices.size();\n\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                if (prices[j] <= prices[i])\n                {\n                    prices[i] -= prices[j];\n                    break;\n                }\n            }\n        }\n\n        return prices;\n    }\n};", "number": "1475"}, "1221": {"link": "https://leetcode.com/problems/split-a-string-in-balanced-strings", "name": "Split a String in Balanced Strings", "difficulty": "Easy", "statement": "<div><p><i data-stringify-type=\"italic\">Balanced</i>&nbsp;strings are those who have equal quantity of 'L' and 'R' characters.</p>\n\n<p>Given a balanced string&nbsp;<code data-stringify-type=\"code\">s</code>&nbsp;split it in the maximum amount of balanced strings.</p>\n\n<p>Return the maximum amount of splitted balanced strings.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> s = \"RLRRLLRLRL\"\n<strong>Output:</strong> 4\n<strong>Explanation: </strong>s can be split into \"RL\", \"RRLL\", \"RL\", \"RL\", each substring contains same number of 'L' and 'R'.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> s = \"RLLLLRRRLR\"\n<strong>Output:</strong> 3\n<strong>Explanation: </strong>s can be split into \"RL\", \"LLLRRR\", \"LR\", each substring contains same number of 'L' and 'R'.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> s = \"LLLLRRRR\"\n<strong>Output:</strong> 1\n<strong>Explanation: </strong>s can be split into \"LLLLRRRR\".\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><strong>Input:</strong> s = \"RLRRRLLRLL\"\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>s can be split into \"RL\", \"RRRLLRLL\", since each substring contains an equal number of 'L' and 'R'\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i] = 'L' or 'R'</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int balancedStringSplit(string s)\n    {\n\n        int count = 0;\n        int diff = 0;\n        int n = s.length();\n\n        for(char i: s) {\n            if (i == 'L') diff--;\n            else diff++;\n\n            if (diff == 0){\n                count ++;\n            }\n        }\n\n        return count;\n    }\n};", "number": "1221"}, "1309": {"link": "https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping", "name": "Decrypt String from Alphabet to Integer Mapping", "difficulty": "Easy", "statement": "<div><p>Given a string <code>s</code> formed by digits (<code>'0'</code> - <code>'9'</code>)&nbsp;and <code>'#'</code>&nbsp;.&nbsp;We want to map <code>s</code> to English lowercase characters as follows:</p>\n\n<ul>\n\t<li>Characters (<code>'a'</code> to <code>'i')</code> are&nbsp;represented by&nbsp;(<code>'1'</code> to&nbsp;<code>'9'</code>)&nbsp;respectively.</li>\n\t<li>Characters (<code>'j'</code> to <code>'z')</code> are represented by (<code>'10#'</code>&nbsp;to&nbsp;<code>'26#'</code>)&nbsp;respectively.&nbsp;</li>\n</ul>\n\n<p>Return the string formed after mapping.</p>\n\n<p>It's guaranteed that a unique mapping will always exist.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> s = \"10#11#12\"\n<strong>Output:</strong> \"jkab\"\n<strong>Explanation:</strong> \"j\" -&gt; \"10#\" , \"k\" -&gt; \"11#\" , \"a\" -&gt; \"1\" , \"b\" -&gt; \"2\".\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> s = \"1326#\"\n<strong>Output:</strong> \"acz\"\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> s = \"25#\"\n<strong>Output:</strong> \"y\"\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><strong>Input:</strong> s = \"12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#\"\n<strong>Output:</strong> \"abcdefghijklmnopqrstuvwxyz\"\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>s[i]</code> only contains digits letters (<code>'0'</code>-<code>'9'</code>) and <code>'#'</code>&nbsp;letter.</li>\n\t<li><code>s</code> will be valid string&nbsp;such that mapping is always possible.</li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string freqAlphabets(string s) {\n\n        stringstream res;\n\n        int n = s.length();\n\n        for(int i = 0; i < n; i++) {\n            if (i+2 < n && s[i+2] == '#') {\n\n                int a = (int)s[i] - 48;\n                int b = (int)s[i+1] - 48;\n\n                char r = (char)(106 + (a-1)*10 + b);\n                res << r;\n                i += 2;\n            }\n            else {\n                char r = (char)((int)s[i] + 48);\n                res << r;\n            }\n        }\n\n        return res.str();\n        \n    }\n};", "number": "1309"}, "1351": {"link": "https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix", "name": "Count Negative Numbers in a Sorted Matrix", "difficulty": "Easy", "statement": "<div><p>Given a <code>m&nbsp;* n</code>&nbsp;matrix <code>grid</code>&nbsp;which is sorted in non-increasing order both row-wise and column-wise.&nbsp;</p>\n\n<p>Return the number of <strong>negative</strong> numbers in&nbsp;<code>grid</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> There are 8 negatives number in the matrix.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> grid = [[3,2],[1,0]]\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> grid = [[1,-1],[-1,-1]]\n<strong>Output:</strong> 3\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><strong>Input:</strong> grid = [[-1]]\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>-100 &lt;= grid[i][j] &lt;= 100</code></li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countNegatives(vector<vector<int>>& grid) {\n\n        int count = 0;\n\n        for(vector<int> x: grid) {\n            for(int a: x) {\n                if (a < 0) ++count;\n            }\n        }\n        return count;\n        \n    }\n};", "number": "1351"}, "1403": {"link": "https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order", "name": "Minimum Subsequence in Non-Increasing Order", "difficulty": "Easy", "statement": "<div><p>Given the array <code>nums</code>, obtain a subsequence of the array whose sum of elements is <strong>strictly greater</strong> than the sum of the non&nbsp;included elements in such subsequence.&nbsp;</p>\n\n<p>If there are multiple solutions, return the subsequence with <strong>minimum size</strong> and if there still exist multiple solutions, return the subsequence with the <strong>maximum total sum</strong> of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.&nbsp;</p>\n\n<p>Note that the solution with the given constraints is guaranteed to be&nbsp;<strong>unique</strong>. Also return the answer sorted in <strong>non-increasing</strong> order.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [4,3,10,9,8]\n<strong>Output:</strong> [10,9] \n<strong>Explanation:</strong> The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included, however, the subsequence [10,9] has the maximum total sum of its elements.&nbsp;\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [4,4,7,6,7]\n<strong>Output:</strong> [7,7,6] \n<strong>Explanation:</strong> The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to returned in non-decreasing order.  \n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> nums = [6]\n<strong>Output:</strong> [6]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> minSubsequence(vector<int>& nums) {\n\n        sort(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.end());\n        int sum = 0;\n        int totalsum = 0;\n        vector<int> res;\n\n        for(int i: nums)\n            totalsum += i;\n\n        for (int i: nums) {\n            sum += i;\n            res.push_back(i);\n            if (sum > totalsum / 2) {\n                break;\n            }\n        }\n\n        return res;\n        \n    }\n};", "number": "1403"}, "1389": {"link": "https://leetcode.com/problems/create-target-array-in-the-given-order", "name": "Create Target Array in the Given Order", "difficulty": "Easy", "statement": "<div><p>Given two arrays of integers&nbsp;<code>nums</code> and <code>index</code>. Your task is to create <em>target</em> array under the following rules:</p>\n\n<ul>\n\t<li>Initially <em>target</em> array is empty.</li>\n\t<li>From left to right read nums[i] and index[i], insert at index <code>index[i]</code>&nbsp;the value <code>nums[i]</code>&nbsp;in&nbsp;<em>target</em> array.</li>\n\t<li>Repeat the previous step until there are no elements to read in <code>nums</code> and <code>index.</code></li>\n</ul>\n\n<p>Return the <em>target</em> array.</p>\n\n<p>It is guaranteed that the insertion operations will be valid.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [0,1,2,3,4], index = [0,1,2,2,1]\n<strong>Output:</strong> [0,4,1,3,2]\n<strong>Explanation:</strong>\nnums       index     target\n0            0        [0]\n1            1        [0,1]\n2            2        [0,1,2]\n3            2        [0,1,3,2]\n4            1        [0,4,1,3,2]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,2,3,4,0], index = [0,1,2,3,0]\n<strong>Output:</strong> [0,1,2,3,4]\n<strong>Explanation:</strong>\nnums       index     target\n1            0        [1]\n2            1        [1,2]\n3            2        [1,2,3]\n4            3        [1,2,3,4]\n0            0        [0,1,2,3,4]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1], index = [0]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>\n\t<li><code>nums.length == index.length</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n\t<li><code>0 &lt;= index[i] &lt;= i</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    vector<int> createTargetArray(vector<int> &nums, vector<int> &index)\n    {\n\n        int n = nums.size();\n\n        vector<int> res;\n\n        for (int i = 0; i < n; i++)\n        {\n            res.insert(res.begin() + index[i], nums[i]);\n        }\n\n        return res;\n    }\n};", "number": "1389"}, "1470": {"link": "https://leetcode.com/problems/shuffle-the-array", "name": "Shuffle the Array", "difficulty": "Easy", "statement": "<div><p>Given the array <code>nums</code> consisting of <code>2n</code> elements in the form <code>[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>,y<sub>1</sub>,y<sub>2</sub>,...,y<sub>n</sub>]</code>.</p>\n\n<p><em>Return the array in the form</em> <code>[x<sub>1</sub>,y<sub>1</sub>,x<sub>2</sub>,y<sub>2</sub>,...,x<sub>n</sub>,y<sub>n</sub>]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [2,5,1,3,4,7], n = 3\n<strong>Output:</strong> [2,3,5,4,1,7] \n<strong>Explanation:</strong> Since x<sub>1</sub>=2, x<sub>2</sub>=5, x<sub>3</sub>=1, y<sub>1</sub>=3, y<sub>2</sub>=4, y<sub>3</sub>=7 then the answer is [2,3,5,4,1,7].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,2,3,4,4,3,2,1], n = 4\n<strong>Output:</strong> [1,4,2,3,3,2,4,1]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,1,2,2], n = 2\n<strong>Output:</strong> [1,2,1,2]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n\t<li><code>nums.length == 2n</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\n</ul></div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> res;\n        for(int i = 0; i < n; i++) {\n            res.push_back(nums[i]);\n            res.push_back(nums[i + n]);\n        }\n        return res;\n    }\n};", "number": "1470"}, "1486": {"link": "https://leetcode.com/problems/xor-operation-in-an-array", "name": "XOR Operation in an Array", "difficulty": "Easy", "statement": "<div><p>Given an integer <code>n</code> and an integer <code>start</code>.</p>\n\n<p>Define an array <code>nums</code> where <code>nums[i] = start + 2*i</code> (0-indexed) and <code>n == nums.length</code>.</p>\n\n<p>Return the bitwise&nbsp;XOR&nbsp;of all elements of <code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> n = 5, start = 0\n<strong>Output:</strong> 8\n<strong>Explanation: </strong>Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.\nWhere \"^\" corresponds to bitwise XOR operator.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> n = 4, start = 3\n<strong>Output:</strong> 8\n<strong>Explanation: </strong>Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8.</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> n = 1, start = 7\n<strong>Output:</strong> 7\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><strong>Input:</strong> n = 10, start = 5\n<strong>Output:</strong> 2\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n\t<li><code>0 &lt;= start &lt;= 1000</code></li>\n\t<li><code>n == nums.length</code></li>\n</ul></div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int xorOperation(int n, int start) {\n        int res = start;\n\n        for(int i = 1; i < n; i++) {\n            res ^= (start + 2 * i);\n        }\n\n        return res;\n    }\n};", "number": "1486"}, "1450": {"link": "https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time", "name": "Number of Students Doing Homework at a Given Time", "difficulty": "Easy", "statement": "<div><p>Given two integer arrays <code>startTime</code> and <code>endTime</code> and given an integer <code>queryTime</code>.</p>\n\n<p>The <code>ith</code> student started doing their homework at the time <code>startTime[i]</code> and finished it at time <code>endTime[i]</code>.</p>\n\n<p>Return <em>the number of students</em> doing their homework at time <code>queryTime</code>. More formally, return the number of students where <code>queryTime</code>&nbsp;lays in the interval <code>[startTime[i], endTime[i]]</code> inclusive.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We have 3 students where:\nThe first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.\nThe second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.\nThe third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> startTime = [4], endTime = [4], queryTime = 4\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The only student was doing their homework at the queryTime.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> startTime = [4], endTime = [4], queryTime = 5\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><strong>Input:</strong> startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre><strong>Input:</strong> startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>startTime.length == endTime.length</code></li>\n\t<li><code>1 &lt;= startTime.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;=&nbsp;queryTime &lt;= 1000</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {\n\n        int count = 0;\n\n        for(int i = 0; i < startTime.size(); i++) {\n            if (queryTime >= startTime[i] && queryTime <= endTime[i]) ++count;\n        }\n\n        return count;\n        \n    }\n};", "number": "1450"}, "905": {"link": "https://leetcode.com/problems/sort-array-by-parity", "name": "Sort Array By Parity", "difficulty": "Easy", "statement": "<div><p>Given an array <code>A</code> of non-negative integers, return an array consisting of all the even elements of <code>A</code>, followed by all the odd elements of <code>A</code>.</p>\n\n<p>You may return any answer array that satisfies this condition.</p>\n\n<p>&nbsp;</p>\n\n<div>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-1-1\">[3,1,2,4]</span>\n<strong>Output: </strong><span id=\"example-output-1\">[2,4,3,1]</span>\nThe outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Note:</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= A.length &lt;= 5000</code></li>\n\t<li><code>0 &lt;= A[i] &lt;= 5000</code></li>\n</ol>\n</div>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> sortArrayByParity(vector<int>& A) {\n\n        vector<int> even;\n        vector<int> odd;\n        for(int i: A) if (i%2) odd.push_back(i); else even.push_back(i);\n        for(int i: odd) even.push_back(i);\n        return even;\n\n    }\n};", "number": "905"}, "561": {"link": "https://leetcode.com/problems/array-partition-i", "name": "Array Partition I", "difficulty": "Easy", "statement": "<div><p>\nGiven an array of <b>2n</b> integers, your task is to group these integers into <b>n</b> pairs of integer, say (a<sub>1</sub>, b<sub>1</sub>), (a<sub>2</sub>, b<sub>2</sub>), ..., (a<sub>n</sub>, b<sub>n</sub>) which makes sum of min(a<sub>i</sub>, b<sub>i</sub>) for all i from 1 to n as large as possible.\n</p>\n\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> [1,4,3,2]\n\n<b>Output:</b> 4\n<b>Explanation:</b> n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).\n</pre>\n<p></p>\n\n<p><b>Note:</b><br>\n</p><ol>\n<li><b>n</b> is a positive integer, which is in the range of [1, 10000].</li>\n<li>All the integers in the array will be in the range of [-10000, 10000].</li>\n</ol>\n<p></p></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int arrayPairSum(vector<int>& nums) {\n\n       sort(nums.begin(), nums.end());\n\n       int n = nums.size();\n       int res = 0;\n       for(int i = 0; i < n; i += 2)\n            res += nums[i];\n        \n        return res;\n        \n    }\n};", "number": "561"}, "1374": {"link": "https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts", "name": "Generate a String With Characters That Have Odd Counts", "difficulty": "Easy", "statement": "<div><p>Given an&nbsp;integer <code>n</code>, <em>return a string with <code>n</code>&nbsp;characters such that each character in such string occurs <strong>an odd number of times</strong></em>.</p>\n\n<p>The returned string must contain only lowercase English letters. If there are multiples valid strings, return <strong>any</strong> of them. &nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> n = 4\n<strong>Output:</strong> \"pppz\"\n<strong>Explanation:</strong> \"pppz\" is a valid string since the character 'p' occurs three times and the character 'z' occurs once. Note that there are many other valid strings such as \"ohhh\" and \"love\".\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> n = 2\n<strong>Output:</strong> \"xy\"\n<strong>Explanation:</strong> \"xy\" is a valid string since the characters 'x' and 'y' occur once. Note that there are many other valid strings such as \"ag\" and \"ur\".\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> n = 7\n<strong>Output:</strong> \"holasss\"\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    string generateTheString(int n)\n    {\n\n        stringstream ss;\n\n        if (n % 2)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                ss << 'a';\n            }\n        }\n        else\n        {\n            for (int i = 0; i < n - 1; i++)\n            {\n                ss << 'a';\n            }\n                ss << 'b';\n        }\n\n        return ss.str();\n    }\n};", "number": "1374"}, "1323": {"link": "https://leetcode.com/problems/maximum-69-number", "name": "Maximum 69 Number", "difficulty": "Easy", "statement": "<div><p>Given a positive integer <code>num</code> consisting only of digits 6 and 9.</p>\n\n<p>Return the maximum number you can get by changing <strong>at most</strong> one digit (6 becomes 9, and 9 becomes 6).</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> num = 9669\n<strong>Output:</strong> 9969\n<strong>Explanation:</strong> \nChanging the first digit results in 6669.\nChanging the second digit results in 9969.\nChanging the third digit results in 9699.\nChanging the fourth digit results in 9666.&nbsp;\nThe maximum number is 9969.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> num = 9996\n<strong>Output:</strong> 9999\n<strong>Explanation:</strong> Changing the last digit 6 to 9 results in the maximum number.</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> num = 9999\n<strong>Output:</strong> 9999\n<strong>Explanation:</strong> It is better not to apply any change.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num &lt;= 10^4</code></li>\n\t<li><code>num</code>'s digits are 6 or 9.</li>\n</ul></div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n#include <string.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximum69Number (int num) {\n\n        int temp = num;\n        \n        int mult = 1;\n        int val = 0;\n\n        while(num) {\n            int rem = num%10;\n            if (rem == 6) {\n                val = 3*mult;\n            }\n            mult *= 10;\n            num /= 10;\n        }\n\n        return temp + val;\n    }\n};", "number": "1323"}, "1299": {"link": "https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side", "name": "Replace Elements with Greatest Element on Right Side", "difficulty": "Easy", "statement": "<div><p>Given an array <code>arr</code>,&nbsp;replace every element in that array with the greatest element among the elements to its&nbsp;right, and replace the last element with <code>-1</code>.</p>\n\n<p>After doing so, return the array.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> arr = [17,18,5,4,6,1]\n<strong>Output:</strong> [18,6,6,6,1,-1]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> replaceElements(vector<int>& arr) {\n\n        vector<int> res;\n        int n = arr.size();\n        for (int i: arr) {\n            res.push_back(-1);\n        }\n\n        for(int i = 0; i < n; i++) {\n            for(int j = i+1; j < n; j++) {\n                if (arr[j] > res[i]) {\n                    res[i] = arr[j];\n                }\n            }\n        }\n\n        return res;\n        \n    }\n};", "number": "1299"}, "1512": {"link": "https://leetcode.com/problems/number-of-good-pairs", "name": "Number of Good Pairs", "difficulty": "Easy", "statement": "<div><p>Given an array of integers&nbsp;<code>nums</code>.</p>\n\n<p>A pair&nbsp;<code>(i,j)</code>&nbsp;is called <em>good</em> if&nbsp;<code>nums[i]</code> == <code>nums[j]</code> and <code>i</code> &lt; <code>j</code>.</p>\n\n<p>Return the number of <em>good</em> pairs.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,2,3,1,1,3]\n<strong>Output:</strong> 4\n<strong>Explanation: </strong>There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,1,1,1]\n<strong>Output:</strong> 6\n<strong>Explanation: </strong>Each pair in the array are <em>good</em>.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,2,3]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n</ul></div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numIdenticalPairs(vector<int>& nums) {\n\n        int visited[101];\n        fill_n(visited, 101, 0);\n\n        int count = 0;\n\n        for (int i: nums) {\n            visited[i] += 1;\n        }\n\n        for (int i: visited) {\n            count += (i * (i-1)) / 2;\n        }\n\n        return count;\n    }\n};", "number": "1512"}, "1436": {"link": "https://leetcode.com/problems/destination-city", "name": "Destination City", "difficulty": "Easy", "statement": "<div><p>You are given the array <code>paths</code>, where <code>paths[i] = [cityA<sub>i</sub>, cityB<sub>i</sub>]</code> means there&nbsp;exists a direct path going from <code>cityA<sub>i</sub></code> to <code>cityB<sub>i</sub></code>. <em>Return the destination city, that is, the city without any path outgoing to another city.</em></p>\n\n<p>It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\n<strong>Output:</strong> \"Sao Paulo\" \n<strong>Explanation:</strong> Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -&gt; \"New York\" -&gt; \"Lima\" -&gt; \"Sao Paulo\".\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\n<strong>Output:</strong> \"A\"\n<strong>Explanation:</strong> All possible trips are:&nbsp;\n\"D\" -&gt; \"B\" -&gt; \"C\" -&gt; \"A\".&nbsp;\n\"B\" -&gt; \"C\" -&gt; \"A\".&nbsp;\n\"C\" -&gt; \"A\".&nbsp;\n\"A\".&nbsp;\nClearly the destination city is \"A\".\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> paths = [[\"A\",\"Z\"]]\n<strong>Output:</strong> \"Z\"\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= paths.length &lt;= 100</code></li>\n\t<li><code>paths[i].length == 2</code></li>\n\t<li><code>1 &lt;=&nbsp;cityA<sub>i</sub>.length,&nbsp;cityB<sub>i</sub>.length &lt;= 10</code></li>\n\t<li><code>cityA<sub>i&nbsp;</sub><font face=\"monospace\">!=&nbsp;</font>cityB<sub>i</sub></code></li>\n\t<li>All strings&nbsp;consist of lowercase and uppercase English letters and the space character.</li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string destCity(vector<vector<string>>& paths) {\n        \n\n        set<string> all;\n        for (vector<string> path: paths) {\n            all.insert(path[0]);\n            all.insert(path[1]);\n        }\n\n        set<string> outonly;\n        for (vector<string> path: paths) {\n            outonly.insert(path[0]);\n        }\n\n        string city;\n\n        for(string c: all) {\n            if (outonly.find(c) == outonly.end()) {\n                city = c;\n                break;\n            }\n        }\n\n        return city;\n\n    }\n};", "number": "1436"}, "938": {"link": "https://leetcode.com/problems/range-sum-of-bst", "name": "Range Sum of BST", "difficulty": "Easy", "statement": "<div><p>Given the <code>root</code> node of a binary search tree, return the sum of values of all nodes with value between <code>L</code> and <code>R</code> (inclusive).</p>\n\n<p>The binary search tree is guaranteed to have unique values.</p>\n\n<p>&nbsp;</p>\n\n<div>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input: </strong>root = <span id=\"example-input-1-1\">[10,5,15,3,7,null,18]</span>, L = <span id=\"example-input-1-2\">7</span>, R = <span id=\"example-input-1-3\">15</span>\n<strong>Output: </strong><span id=\"example-output-1\">32</span>\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input: </strong>root = <span id=\"example-input-2-1\">[10,5,15,3,7,13,18,1,null,6]</span>, L = <span id=\"example-input-2-2\">6</span>, R = <span id=\"example-input-2-3\">10</span>\n<strong>Output: </strong><span id=\"example-output-2\">23</span>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Note:</strong></p>\n\n<ol>\n\t<li>The number of nodes in the tree is at most <code>10000</code>.</li>\n\t<li>The final answer is guaranteed to be less than <code>2^31</code>.</li>\n</ol>\n</div>\n</div></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution\n{\npublic:\n    int rangeSumBST(TreeNode *root, int L, int R)\n    {\n\n        int sum = 0;\n        if (root)\n        {\n            sum = root->val >= L && root->val <= R ? root->val : 0;\n            sum += rangeSumBST(root->left, L, R);\n            sum += rangeSumBST(root->right, L, R);\n        }\n\n        return sum;\n    }\n};", "number": "938"}, "590": {"link": "https://leetcode.com/problems/n-ary-tree-postorder-traversal", "name": "N-ary Tree Postorder Traversal", "difficulty": "Easy", "statement": "<div><p>Given an n-ary tree, return the <i>postorder</i> traversal of its nodes' values.</p>\n\n<p><em>Nary-Tree input serialization&nbsp;is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>Follow up:</strong></p>\n\n<p>Recursive solution is trivial, could you do it iteratively?</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\"></p>\n\n<pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [5,6,3,2,4,1]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\"></p>\n\n<pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\n\t<li>The total number of nodes is between <code>[0,&nbsp;10^4]</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> postorder(Node* root) {\n\n        vector<int> res;\n        if (!root) {\n            return res;\n        }\n\n        reverse((root->children).begin(), (root->children).end());\n\n        for (Node* node: root->children) {\n            vector<int> temp = postorder(node);\n            res.insert(res.begin(), temp.begin(), temp.end());\n        }\n\n        res.push_back(root->val);\n        return res;\n    }\n};", "number": "590"}, "1281": {"link": "https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer", "name": "Subtract the Product and Sum of Digits of an Integer", "difficulty": "Easy", "statement": "<div>Given an integer number <code>n</code>, return the difference between the product of its digits and the sum of its digits.\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> n = 234\n<strong>Output:</strong> 15 \n<b>Explanation:</b> \nProduct of digits = 2 * 3 * 4 = 24 \nSum of digits = 2 + 3 + 4 = 9 \nResult = 24 - 9 = 15\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> n = 4421\n<strong>Output:</strong> 21\n<b>Explanation: \n</b>Product of digits = 4 * 4 * 2 * 1 = 32 \nSum of digits = 4 + 4 + 2 + 1 = 11 \nResult = 32 - 11 = 21\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10^5</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int sum = 0;\n        int prod = 1;\n\n        while (n) {\n            int rem = n % 10;\n            sum += rem;\n            prod *= rem;\n            n /= 10;\n        }\n\n        if (sum > prod) {\n            return sum - prod;\n        }\n        return prod - sum;\n    }\n};", "number": "1281"}, "852": {"link": "https://leetcode.com/problems/peak-index-in-a-mountain-array", "name": "Peak Index in a Mountain Array", "difficulty": "Easy", "statement": "<div><p>Let's call an array <code>arr</code> a <strong>mountain</strong>&nbsp;if the following properties hold:</p>\n\n<ul>\n\t<li><code>arr.length &gt;= 3</code></li>\n\t<li>There exists some <code>i</code> with&nbsp;<code>0 &lt; i&nbsp;&lt; arr.length - 1</code>&nbsp;such that:\n\t<ul>\n\t\t<li><code>arr[0] &lt; arr[1] &lt; ... arr[i-1] &lt; arr[i] </code></li>\n\t\t<li><code>arr[i] &gt; arr[i+1] &gt; ... &gt; arr[arr.length - 1]</code></li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Given an integer array arr that is <strong>guaranteed</strong> to be&nbsp;a mountain, return any&nbsp;<code>i</code>&nbsp;such that&nbsp;<code>arr[0] &lt; arr[1] &lt; ... arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> arr = [0,1,0]\n<strong>Output:</strong> 1\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> arr = [0,2,1,0]\n<strong>Output:</strong> 1\n</pre><p><strong>Example 3:</strong></p>\n<pre><strong>Input:</strong> arr = [0,10,5,2]\n<strong>Output:</strong> 1\n</pre><p><strong>Example 4:</strong></p>\n<pre><strong>Input:</strong> arr = [3,4,5,1]\n<strong>Output:</strong> 2\n</pre><p><strong>Example 5:</strong></p>\n<pre><strong>Input:</strong> arr = [24,69,100,99,79,78,67,36,26,19]\n<strong>Output:</strong> 2\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 10<sup>6</sup></code></li>\n\t<li><code>arr</code> is <strong>guaranteed</strong> to be a mountain array.</li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& A) {\n\n        int n = A.size();\n        for (int i = 1; i < n-1; i++) {\n            if (A[i] > A[i-1] && A[i] > A[i+1]) return i;\n        }\n        return  -1;\n    }\n};", "number": "852"}, "617": {"link": "https://leetcode.com/problems/merge-two-binary-trees", "name": "Merge Two Binary Trees", "difficulty": "Easy", "statement": "<div><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>\n\n<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>\n\n<p><b>Example 1:</b></p>\n\n<pre><b>Input:</b> \n\tTree 1                     Tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \n<b>Output:</b> \nMerged tree:\n\t     3\n\t    / \\\n\t   4   5\n\t  / \\   \\ \n\t 5   4   7\n</pre>\n\n<p>&nbsp;</p>\n\n<p><b>Note:</b> The merging process must start from the root nodes of both trees.</p>\n</div>", "language": "c", "solution": "#include<stdio.h>\n#include <stdlib.h>  \n\nstruct TreeNode\n{\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n\nstruct TreeNode *mergeTrees(struct TreeNode *t1, struct TreeNode *t2)\n{\n\n    if (!t1) return t2;\n    if (!t2) return t1;\n\n    t1->val = t1->val + t2->val;\n\n    if (t1->left && t2->left)\n        t1->left = mergeTrees(t1->left, t2->left);\n    else if (t1->left)\n        t1->left = t1->left;\n    else if (t2->left)\n        t1->left = t2->left;\n\n    if (t1->right && t2->right)\n        t1->right = mergeTrees(t1->right, t2->right);\n    else if (t1->right)\n        t1->right = t1->right;\n    else if (t2->right)\n        t1->right = t2->right;\n\n    return t1;\n}", "number": "617"}, "1304": {"link": "https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero", "name": "Find N Unique Integers Sum up to Zero", "difficulty": "Easy", "statement": "<div><p>Given an integer <code>n</code>, return <strong>any</strong> array containing <code>n</code> <strong>unique</strong>&nbsp;integers such that they add up to 0.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> n = 5\n<strong>Output:</strong> [-7,-1,1,3,4]\n<strong>Explanation:</strong> These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> n = 3\n<strong>Output:</strong> [-1,0,1]\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> n = 1\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 1000</code></li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> sumZero(int n) {\n\n        vector<int> res;\n\n        for (int i = 1; i <= (n/2); i++) {\n            res.push_back(i);\n            res.push_back(i*-1);\n        }\n\n        if (n%2)\n            res.push_back(0);\n\n        return res;\n        \n    }\n};", "number": "1304"}, "1534": {"link": "https://leetcode.com/problems/count-good-triplets", "name": "Count Good Triplets", "difficulty": "Easy", "statement": "<div><p>Given an array of integers <code>arr</code>, and three integers&nbsp;<code>a</code>,&nbsp;<code>b</code>&nbsp;and&nbsp;<code>c</code>. You need to find the number of good triplets.</p>\n\n<p>A triplet <code>(arr[i], arr[j], arr[k])</code>&nbsp;is <strong>good</strong> if the following conditions are true:</p>\n\n<ul>\n\t<li><code>0 &lt;= i &lt; j &lt; k &lt;&nbsp;arr.length</code></li>\n\t<li><code>|arr[i] - arr[j]| &lt;= a</code></li>\n\t<li><code>|arr[j] - arr[k]| &lt;= b</code></li>\n\t<li><code>|arr[i] - arr[k]| &lt;= c</code></li>\n</ul>\n\n<p>Where <code>|x|</code> denotes the absolute value of <code>x</code>.</p>\n\n<p>Return<em> the number of good triplets</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>&nbsp;There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> arr = [1,1,2,2,3], a = 0, b = 0, c = 1\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>No triplet satisfies all conditions.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= arr.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>0 &lt;= a, b, c &lt;= 1000</code></li>\n</ul></div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countGoodTriplets(vector<int>& arr, int a, int b, int c) {\n        int n = arr.size();\n\n        int count = 0;\n\n        for(int i= 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                for (int k = j+1; k < n; k++) {\n                    if ( abs(arr[i] - arr[j]) <= a && abs(arr[j]-arr[k]) <= b && abs(arr[i] - arr[k])<=c ) count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n};", "number": "1534"}, "1207": {"link": "https://leetcode.com/problems/unique-number-of-occurrences", "name": "Unique Number of Occurrences", "difficulty": "Easy", "statement": "<div><p>Given an array of integers <code>arr</code>,&nbsp;write a function that returns <code>true</code> if and only if the number of occurrences of each value in the array is unique.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> arr = [1,2,2,1,1,3]\n<strong>Output:</strong> true\n<strong>Explanation:</strong>&nbsp;The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> arr = [1,2]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> arr = [-3,0,1,-3,1,1,1,-3,10,0]\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length&nbsp;&lt;= 1000</code></li>\n\t<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool uniqueOccurrences(vector<int>& arr) {\n\n        vector<int> count;\n        for(int i = 0; i < 2001; i++) {\n            count.push_back(0);\n        }\n\n        for (int i: arr)\n            ++count[i+1000];\n\n        sort(count.begin(), count.end());\n        int n = count.size();\n        \n        for(int i = 0; i < n - 1; i++) {\n            if (count[i] > 0 && count[i] == count[i+1]) return false;\n        }\n        return true;\n        \n    }\n};", "number": "1207"}, "1313": {"link": "https://leetcode.com/problems/decompress-run-length-encoded-list", "name": "Decompress Run-Length Encoded List", "difficulty": "Easy", "statement": "<div><p>We are given a list <code>nums</code> of integers representing a list compressed with run-length encoding.</p>\n\n<p>Consider each adjacent pair&nbsp;of elements <code>[freq, val] = [nums[2*i], nums[2*i+1]]</code>&nbsp;(with <code>i &gt;= 0</code>).&nbsp; For each such pair, there are <code>freq</code> elements with value <code>val</code> concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.</p>\n\n<p>Return the decompressed list.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> [2,4,4,4]\n<strong>Explanation:</strong> The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].\nThe second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].\nAt the end the concatenation [2] + [4,4,4] is [2,4,4,4].\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,1,2,3]\n<strong>Output:</strong> [1,3,3]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>nums.length % 2 == 0</code></li>\n\t<li><code><font face=\"monospace\">1 &lt;= nums[i] &lt;= 100</font></code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> decompressRLElist(vector<int>& nums) {\n\n        int n = nums.size();\n\n        vector<int> res;\n\n        for (int i = 0; i < n / 2; i ++) {\n            for(int j = 0; j < nums[2*i]; j ++) {\n                res.push_back(nums[2*i + 1]);\n            }\n        }\n\n        return res;\n        \n    }\n};", "number": "1313"}, "589": {"link": "https://leetcode.com/problems/n-ary-tree-preorder-traversal", "name": "N-ary Tree Preorder Traversal", "difficulty": "Easy", "statement": "<div><p>Given an n-ary tree, return the <i>preorder</i> traversal of its nodes' values.</p>\n\n<p><em>Nary-Tree input serialization&nbsp;is represented in their level order traversal, each group of children is separated by the null value (See examples).</em></p>\n\n<p>&nbsp;</p>\n\n<p><strong>Follow up:</strong></p>\n\n<p>Recursive solution is trivial, could you do it iteratively?</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<p><img src=\"https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png\" style=\"width: 100%; max-width: 300px;\"></p>\n\n<pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]\n<strong>Output:</strong> [1,3,5,6,2,4]\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png\" style=\"width: 296px; height: 241px;\"></p>\n\n<pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n<strong>Output:</strong> [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The height of the n-ary tree is less than or equal to <code>1000</code></li>\n\t<li>The total number of nodes is between <code>[0,&nbsp;10^4]</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> preorder(Node* root) {\n\n        vector<int> res;\n        if (!root) {\n            return res;\n        }\n\n        reverse((root->children).begin(), (root->children).end());\n\n        res.push_back(root->val);\n\n        for (Node* node: root->children) {\n            vector<int> temp = preorder(node);\n            res.insert(res.begin() + 1, temp.begin(), temp.end());\n        }\n        return res;\n    }\n};", "number": "589"}, "942": {"link": "https://leetcode.com/problems/di-string-match", "name": "DI String Match", "difficulty": "Easy", "statement": "<div><p>Given a string <code>S</code> that <strong>only</strong> contains \"I\" (increase) or \"D\" (decrease), let <code>N = S.length</code>.</p>\n\n<p>Return <strong>any</strong> permutation <code>A</code> of <code>[0, 1, ..., N]</code> such that for all <code>i = 0,&nbsp;..., N-1</code>:</p>\n\n<ul>\n\t<li>If <code>S[i] == \"I\"</code>, then <code>A[i] &lt; A[i+1]</code></li>\n\t<li>If <code>S[i] == \"D\"</code>, then <code>A[i] &gt; A[i+1]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-1-1\">\"IDID\"</span>\n<strong>Output: </strong><span id=\"example-output-1\">[0,4,1,3,2]</span>\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-2-1\">\"III\"</span>\n<strong>Output: </strong><span id=\"example-output-2\">[0,1,2,3]</span>\n</pre>\n\n<div>\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-3-1\">\"DDI\"</span>\n<strong>Output: </strong><span id=\"example-output-3\">[3,2,0,1]</span></pre>\n</div>\n</div>\n\n<p>&nbsp;</p>\n\n<p><strong>Note:</strong></p>\n\n<ol>\n\t<li><code>1 &lt;= S.length &lt;= 10000</code></li>\n\t<li><code>S</code> only contains characters <code>\"I\"</code> or <code>\"D\"</code>.</li>\n</ol></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> diStringMatch(string S) {\n\n        vector<int> res;\n\n        int n = S.length();\n\n        if (S[0] == 'I') res.push_back(0);\n        else res.push_back(n);\n\n        int ICount = count(S.begin(), S.end(), 'I');\n        int DCount = n - ICount;\n\n        int I, D;\n        if (S[0] == 'I') {\n            D = DCount;\n            I = D+1;\n        }\n        else {\n            D = DCount - 1;\n            I = D+1;\n        }\n\n        for(char i: S) {\n            if (i == 'I') res.push_back(I++);\n            else res.push_back(D--);\n        }\n\n        return res;\n\n    }\n};", "number": "942"}, "657": {"link": "https://leetcode.com/problems/robot-return-to-origin", "name": "Robot Return to Origin", "difficulty": "Easy", "statement": "<div><p>There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot <strong>ends up at (0, 0)</strong> after it completes its moves.</p>\n\n<p>The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false.</p>\n\n<p><strong>Note</strong>: The way that the robot is \"facing\" is irrelevant. \"R\" will always make the robot move to the right once, \"L\" will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> moves = \"UD\"\n<strong>Output:</strong> true\n<strong>Explanation</strong>: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> moves = \"LL\"\n<strong>Output:</strong> false\n<strong>Explanation</strong>: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false because it is not at the origin at the end of its moves.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> moves = \"RRDD\"\n<strong>Output:</strong> false\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><strong>Input:</strong> moves = \"LDRRLRUULR\"\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= moves.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>moves</code> only contains the characters <code>'U'</code>, <code>'D'</code>, <code>'L'</code> and <code>'R'</code>.</li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    bool judgeCircle(string moves)\n    {\n\n        return count(moves.begin(), moves.end(), 'U') == count(moves.begin(), moves.end(), 'D') && count(moves.begin(), moves.end(), 'L') == count(moves.begin(), moves.end(), 'R');\n    }\n};", "number": "657"}, "1431": {"link": "https://leetcode.com/problems/kids-with-the-greatest-number-of-candies", "name": "Kids With the Greatest Number of Candies", "difficulty": "Easy", "statement": "<div><p>Given the array <code>candies</code> and the integer <code>extraCandies</code>, where <code>candies[i]</code> represents the number of candies that the <strong><em>ith</em></strong> kid has.</p>\n\n<p>For each kid check if there is a way to distribute <code>extraCandies</code> among the kids such that he or she can have the <strong>greatest</strong> number of candies among them.&nbsp;Notice that multiple kids can have the <strong>greatest</strong> number of candies.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> candies = [2,3,5,1,3], extraCandies = 3\n<strong>Output:</strong> [true,true,true,false,true] \n<strong>Explanation:</strong> \nKid 1 has 2 candies and if he or she receives all extra candies (3) will have 5 candies --- the greatest number of candies among the kids. \nKid 2 has 3 candies and if he or she receives at least 2 extra candies will have the greatest number of candies among the kids. \nKid 3 has 5 candies and this is already the greatest number of candies among the kids. \nKid 4 has 1 candy and even if he or she receives all extra candies will only have 4 candies. \nKid 5 has 3 candies and if he or she receives at least 2 extra candies will have the greatest number of candies among the kids. \n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> candies = [4,2,1,1,2], extraCandies = 1\n<strong>Output:</strong> [true,false,false,false,false] \n<strong>Explanation:</strong> There is only 1 extra candy, therefore only kid 1 will have the greatest number of candies among the kids regardless of who takes the extra candy.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> candies = [12,1,12], extraCandies = 10\n<strong>Output:</strong> [true,false,true]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= candies.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= candies[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= extraCandies &lt;= 50</code></li>\n</ul></div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\n        vector<bool> res;\n        long int max = 0;\n        for(int i  = 0; i < candies.size(); i++) {\n            max = max > candies[i] ? max : candies[i];\n        }\n        for(int i: candies) {\n            res.push_back(i + extraCandies >= max);\n        }\n        \n        return res;\n    }\n};", "number": "1431"}, "1252": {"link": "https://leetcode.com/problems/cells-with-odd-values-in-a-matrix", "name": "Cells with Odd Values in a Matrix", "difficulty": "Easy", "statement": "<div><p>Given&nbsp;<code>n</code>&nbsp;and&nbsp;<code>m</code>&nbsp;which are the dimensions of a matrix initialized by zeros and given an array <code>indices</code>&nbsp;where <code>indices[i] = [ri, ci]</code>. For each pair of <code>[ri, ci]</code>&nbsp;you have to increment all cells in row <code>ri</code> and column <code>ci</code>&nbsp;by 1.</p>\n\n<p>Return <em>the number of cells with odd values</em> in the matrix after applying the increment to all <code>indices</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/30/e1.png\" style=\"width: 600px; height: 118px;\">\n<pre><strong>Input:</strong> n = 2, m = 3, indices = [[0,1],[1,1]]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Initial matrix = [[0,0,0],[0,0,0]].\nAfter applying first increment it becomes [[1,2,1],[0,1,0]].\nThe final matrix will be [[1,3,1],[1,3,1]] which contains 6 odd numbers.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/10/30/e2.png\" style=\"width: 600px; height: 150px;\">\n<pre><strong>Input:</strong> n = 2, m = 2, indices = [[1,1],[0,0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Final matrix = [[2,2],[2,2]]. There is no odd number in the final matrix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 50</code></li>\n\t<li><code>1 &lt;= m &lt;= 50</code></li>\n\t<li><code>1 &lt;= indices.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= indices[i][0] &lt;&nbsp;n</code></li>\n\t<li><code>0 &lt;= indices[i][1] &lt;&nbsp;m</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int oddCells(int n, int m, vector<vector<int>> &indices)\n    {\n\n        int arr[n][m];\n\n        for (int i = 0; i < n; i++)\n        {\n            fill_n(arr[i], m, 0);\n        }\n\n        for (vector<int> i : indices)\n        {\n            int r = i[0];\n            int c = i[1];\n\n            for (int k = 0; k < m; k++)\n            {\n                ++arr[r][k];\n            }\n\n            for (int k = 0; k < n; k++)\n            {\n                ++arr[k][c];\n            }\n        }\n\n        int count = 0;\n\n        for(int i = 0; i < n; i++) {\n            for(int j: arr[i]) {\n                count += j%2;\n            }\n        }\n\n        return count;\n    }\n};", "number": "1252"}, "1342": {"link": "https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero", "name": "Number of Steps to Reduce a Number to Zero", "difficulty": "Easy", "statement": "<div><p>Given a non-negative integer <code>num</code>, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> num = 14\n<strong>Output:</strong> 6\n<strong>Explanation:</strong>&nbsp;\nStep 1) 14 is even; divide by 2 and obtain 7.&nbsp;\nStep 2) 7 is odd; subtract 1 and obtain 6.\nStep 3) 6 is even; divide by 2 and obtain 3.&nbsp;\nStep 4) 3 is odd; subtract 1 and obtain 2.&nbsp;\nStep 5) 2 is even; divide by 2 and obtain 1.&nbsp;\nStep 6) 1 is odd; subtract 1 and obtain 0.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> num = 8\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>&nbsp;\nStep 1) 8 is even; divide by 2 and obtain 4.&nbsp;\nStep 2) 4 is even; divide by 2 and obtain 2.&nbsp;\nStep 3) 2 is even; divide by 2 and obtain 1.&nbsp;\nStep 4) 1 is odd; subtract 1 and obtain 0.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> num = 123\n<strong>Output:</strong> 12\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= num &lt;= 10^6</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int numberOfSteps(int num)\n    {\n        int count = 0;\n\n        while (num != 0)\n        {\n            count++;\n            if (num % 2 == 0)\n            {\n                num /= 2;\n            }\n            else {\n                num -= 1;\n            }\n        }\n\n        return count;\n    }\n};", "number": "1342"}, "1108": {"link": "https://leetcode.com/problems/defanging-an-ip-address", "name": "Defanging an IP Address", "difficulty": "Easy", "statement": "<div><p>Given a valid (IPv4) IP <code>address</code>, return a defanged version of that IP address.</p>\n\n<p>A <em>defanged&nbsp;IP address</em>&nbsp;replaces every period <code>\".\"</code> with <code>\"[.]\"</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<pre><strong>Input:</strong> address = \"1.1.1.1\"\n<strong>Output:</strong> \"1[.]1[.]1[.]1\"\n</pre><p><strong>Example 2:</strong></p>\n<pre><strong>Input:</strong> address = \"255.100.50.0\"\n<strong>Output:</strong> \"255[.]100[.]50[.]0\"\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The given <code>address</code> is a valid IPv4 address.</li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    string defangIPaddr(string address)\n    {\n\n        int a, b, c, d;\n\n        char arr[address.length() + 1];\n\n        strcpy(arr, address.c_str());\n\n        sscanf(arr, \"%d.%d.%d.%d\", &a, &b, &c, &d);\n\n        char res_arr[address.length() + 1 + 10];\n\n        sprintf(res_arr, \"%d[.]%d[.]%d[.]%d\", a, b, c, d);\n\n        string res(res_arr);\n\n        return res;\n    }\n};", "number": "1108"}, "700": {"link": "https://leetcode.com/problems/search-in-a-binary-search-tree", "name": "Search in a Binary Search Tree", "difficulty": "Easy", "statement": "<div><p>Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL.</p>\n\n<p>For example,&nbsp;</p>\n\n<pre>Given the tree:\n        4\n       / \\\n      2   7\n     / \\\n    1   3\n\nAnd the value to search: 2\n</pre>\n\n<p>You should return this subtree:</p>\n\n<pre>      2     \n     / \\   \n    1   3\n</pre>\n\n<p>In the example above, if we want to search the value <code>5</code>, since there is no node with value <code>5</code>, we should return <code>NULL</code>.</p>\n\n<p>Note that an empty tree is represented by <code>NULL</code>, therefore you would see the expected output (serialized tree format) as&nbsp;<code>[]</code>, not <code>null</code>.</p>\n</div>", "language": "c", "solution": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct TreeNode\n{\n    int val;\n    struct TreeNode *left;\n    struct TreeNode *right;\n};\n\nstruct TreeNode *searchBST(struct TreeNode *root, int val)\n{\n    if (!root)\n        return NULL;\n\n    if (root->val == val)\n        return root;\n\n    struct TreeNode *left = searchBST(root->left, val);\n    if (left)\n        return left;\n\n    struct TreeNode *right = searchBST(root->right, val);\n    if (right)\n        return right;\n\n    return NULL;\n}", "number": "700"}, "1290": {"link": "https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer", "name": "Convert Binary Number in a Linked List to Integer", "difficulty": "Easy", "statement": "<div><p>Given <code>head</code> which is a reference node to&nbsp;a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.</p>\n\n<p>Return the <em>decimal value</em> of the number in the linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/05/graph-1.png\" style=\"width: 426px; height: 108px;\">\n<pre><strong>Input:</strong> head = [1,0,1]\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> (101) in base 2 = (5) in base 10\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> head = [0]\n<strong>Output:</strong> 0\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> head = [1]\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong>Example 4:</strong></p>\n\n<pre><strong>Input:</strong> head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]\n<strong>Output:</strong> 18880\n</pre>\n\n<p><strong>Example 5:</strong></p>\n\n<pre><strong>Input:</strong> head = [0,0]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The Linked List is not empty.</li>\n\t<li>Number of nodes&nbsp;will not exceed <code>30</code>.</li>\n\t<li>Each node's value is either&nbsp;<code>0</code> or <code>1</code>.</li>\n</ul></div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int getDecimalValue(ListNode* head) {\n\n        int res = 0;\n\n        while(head) {\n            res = res*2 + head->val;\n            head = head->next;\n        }\n\n        return res;\n        \n    }\n};", "number": "1290"}, "977": {"link": "https://leetcode.com/problems/squares-of-a-sorted-array", "name": "Squares of a Sorted Array", "difficulty": "Easy", "statement": "<div><p>Given an array of integers <code>A</code>&nbsp;sorted in non-decreasing order,&nbsp;return an array of the squares of each number,&nbsp;also in sorted non-decreasing order.</p>\n\n<p>&nbsp;</p>\n\n<div>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-1-1\">[-4,-1,0,3,10]</span>\n<strong>Output: </strong><span id=\"example-output-1\">[0,1,9,16,100]</span>\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-2-1\">[-7,-3,2,3,11]</span>\n<strong>Output: </strong><span id=\"example-output-2\">[4,9,9,49,121]</span>\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong><span>Note:</span></strong></p>\n\n<ol>\n\t<li><code><span>1 &lt;= A.length &lt;= 10000</span></code></li>\n\t<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>\n\t<li><code>A</code>&nbsp;is sorted in non-decreasing order.</li>\n</ol>\n</div>\n</div></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& A) {\n\n        vector<int> res;\n\n        for(int i: A) res.push_back(i*i);\n\n        sort(res.begin(), res.end());\n\n        return res;\n        \n    }\n};", "number": "977"}, "1572": {"link": "https://leetcode.com/problems/matrix-diagonal-sum", "name": "Matrix Diagonal Sum", "difficulty": "Easy", "statement": "<div><p>Given a&nbsp;square&nbsp;matrix&nbsp;<code>mat</code>, return the sum of the matrix diagonals.</p>\n\n<p>Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png\" style=\"width: 336px; height: 174px;\">\n<pre><strong>Input:</strong> mat = [[<strong>1</strong>,2,<strong>3</strong>],\n&nbsp;             [4,<strong>5</strong>,6],\n&nbsp;             [<strong>7</strong>,8,<strong>9</strong>]]\n<strong>Output:</strong> 25\n<strong>Explanation: </strong>Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25\nNotice that element mat[1][1] = 5 is counted only once.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> mat = [[<strong>1</strong>,1,1,<strong>1</strong>],\n&nbsp;             [1,<strong>1</strong>,<strong>1</strong>,1],\n&nbsp;             [1,<strong>1</strong>,<strong>1</strong>,1],\n&nbsp;             [<strong>1</strong>,1,1,<strong>1</strong>]]\n<strong>Output:</strong> 8\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> mat = [[<strong>5</strong>]]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == mat.length == mat[i].length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int diagonalSum(vector<vector<int>> &mat)\n    {\n\n        int n = mat.size();\n        int sum = 0;\n        for (int i = 0; i < n; i++)\n        {\n            sum += mat[i][i];\n            if (i != n-i-1) sum += mat[i][n-i-1];\n        }\n        return sum;\n    }\n};", "number": "1572"}, "933": {"link": "https://leetcode.com/problems/number-of-recent-calls", "name": "Number of Recent Calls", "difficulty": "Easy", "statement": "<div><p>Write a class <code>RecentCounter</code> to count recent requests.</p>\n\n<p>It has only one method:&nbsp;<code>ping(int t)</code>, where t represents some time in milliseconds.</p>\n\n<p>Return the number of <code>ping</code>s that have been made from 3000 milliseconds ago until now.</p>\n\n<p>Any ping with time in <code>[t - 3000, t]</code> will count, including the current ping.</p>\n\n<p>It is guaranteed that every call to <code>ping</code> uses a strictly larger value of&nbsp;<code>t</code> than before.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input: </strong>inputs = <span id=\"example-input-1-1\">[\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\"]</span>, inputs = <span id=\"example-input-1-2\">[[],[1],[100],[3001],[3002]]</span>\n<strong>Output: </strong><span id=\"example-output-1\">[null,1,2,3,3]</span></pre>\n\n<p>&nbsp;</p>\n\n<p><strong>Note:</strong></p>\n\n<ol>\n\t<li>Each test case will have at most <code>10000</code> calls to <code>ping</code>.</li>\n\t<li>Each test case will call&nbsp;<code>ping</code> with strictly increasing values of <code>t</code>.</li>\n\t<li>Each call to ping will have <code>1 &lt;= t &lt;= 10^9</code>.</li>\n</ol>\n\n<div>\n<p>&nbsp;</p>\n</div></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass RecentCounter\n{\n\npublic:\n    vector<int> pings;\n    int size;\n    int lastIndex;\n\n    RecentCounter()\n    {\n        this->lastIndex = 0;\n        this->size = 0;\n    }\n\n    int ping(int t)\n    {\n        this->pings.push_back(t);\n        ++this->size;\n        for (; this->lastIndex < this->size && this->pings[this->lastIndex] < t - 3000; ++this->lastIndex)\n            ;\n        return this->size - this->lastIndex;\n    }\n};", "number": "933"}, "1266": {"link": "https://leetcode.com/problems/minimum-time-visiting-all-points", "name": "Minimum Time Visiting All Points", "difficulty": "Easy", "statement": "<div><p>On a plane there are <code>n</code> points with integer coordinates <code>points[i] = [xi, yi]</code>. Your task is to find the minimum time in seconds to visit all points.</p>\n\n<p>You can move according to the next rules:</p>\n\n<ul>\n\t<li>In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second).</li>\n\t<li>You have to visit the points in the same order as they appear in the array.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/14/1626_example_1.PNG\" style=\"width: 500px; height: 428px;\">\n<pre><strong>Input:</strong> points = [[1,1],[3,4],[-1,0]]\n<strong>Output:</strong> 7\n<strong>Explanation: </strong>One optimal path is <strong>[1,1]</strong> -&gt; [2,2] -&gt; [3,3] -&gt; <strong>[3,4] </strong>-&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; <strong>[-1,0]</strong>   \nTime from [1,1] to [3,4] = 3 seconds \nTime from [3,4] to [-1,0] = 4 seconds\nTotal time = 7 seconds</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> points = [[3,2],[-2,2]]\n<strong>Output:</strong> 5\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>points.length == n</code></li>\n\t<li><code>1 &lt;= n&nbsp;&lt;= 100</code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>-1000&nbsp;&lt;= points[i][0], points[i][1]&nbsp;&lt;= 1000</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\n\n        int cost = 0;\n        int n = points.size();\n\n        for(int i = 0; i < n - 1; i++) {\n\n            vector<int> a = points[i];\n            vector<int> b = points[i+1];\n\n            cost += max(abs(a[0]-b[0]), abs(a[1]-b[1]));\n\n            cout << cost << endl;\n\n        }\n        return cost;\n        \n    }\n};", "number": "1266"}, "1051": {"link": "https://leetcode.com/problems/height-checker", "name": "Height Checker", "difficulty": "Easy", "statement": "<div><p>Students are asked to stand in non-decreasing order of heights for an annual photo.</p>\n\n<p>Return the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.</p>\n\n<p>Notice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students&nbsp;remain on their seats.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> heights = [1,1,4,2,1,3]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> \nCurrent array : [1,1,4,2,1,3]\nTarget array  : [1,1,1,2,3,4]\nOn index 2 (0-based) we have 4 vs 1 so we have to move this student.\nOn index 4 (0-based) we have 1 vs 3 so we have to move this student.\nOn index 5 (0-based) we have 3 vs 4 so we have to move this student.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> heights = [5,1,2,3,4]\n<strong>Output:</strong> 5\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> heights = [1,2,3,4,5]\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= heights.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= heights[i] &lt;= 100</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int heightChecker(vector<int> &heights)\n    {\n\n        vector<int> dup = heights;\n        sort(dup.begin(), dup.end());\n        int count = 0;\n        int n = heights.size();\n        for (int i = 0; i < n; i++)\n        {\n            if (dup[i] != heights[i])\n                ++count;\n        }\n\n        return count;\n    }\n};", "number": "1051"}, "1480": {"link": "https://leetcode.com/problems/running-sum-of-1d-array", "name": "Running Sum of 1d Array", "difficulty": "Easy", "statement": "<div><p>Given an array <code>nums</code>. We define a running sum of an array as&nbsp;<code>runningSum[i] = sum(nums[0]\u2026nums[i])</code>.</p>\n\n<p>Return the running sum of <code>nums</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> [1,3,6,10]\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [1,1,1,1,1]\n<strong>Output:</strong> [1,2,3,4,5]\n<strong>Explanation:</strong> Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> nums = [3,1,2,10,1]\n<strong>Output:</strong> [3,4,6,16,17]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-10^6&nbsp;&lt;= nums[i] &lt;=&nbsp;10^6</code></li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    vector<int> runningSum(vector<int> &nums)\n    {\n\n        vector<int> res;\n\n        res.push_back(nums[0]);\n\n        int sum = res[0];\n\n        for (int i = 1; i < nums.size(); i++)\n        {\n            sum += nums[i];\n            res.push_back(sum);\n        }\n\n        return res;\n    }\n};", "number": "1480"}, "1021": {"link": "https://leetcode.com/problems/remove-outermost-parentheses", "name": "Remove Outermost Parentheses", "difficulty": "Easy", "statement": "<div><p>A valid parentheses string is either empty <code>(\"\")</code>, <code>\"(\" + A + \")\"</code>, or <code>A + B</code>, where <code>A</code> and <code>B</code> are valid parentheses strings, and <code>+</code> represents string concatenation.&nbsp; For example, <code>\"\"</code>, <code>\"()\"</code>, <code>\"(())()\"</code>, and <code>\"(()(()))\"</code> are all valid parentheses strings.</p>\n\n<p>A valid parentheses string <code>S</code> is <strong>primitive</strong> if it is nonempty, and there does not exist a way to split it into <code>S = A+B</code>, with <code>A</code> and <code>B</code> nonempty valid parentheses strings.</p>\n\n<p>Given a valid parentheses string <code>S</code>, consider its primitive decomposition: <code>S = P_1 + P_2 + ... + P_k</code>, where <code>P_i</code> are primitive valid parentheses strings.</p>\n\n<p>Return <code>S</code> after removing the outermost parentheses of every primitive string in the primitive decomposition of <code>S</code>.</p>\n\n<p>&nbsp;</p>\n\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-1-1\">\"(()())(())\"</span>\n<strong>Output: </strong><span id=\"example-output-1\">\"()()()\"</span>\n<strong>Explanation: </strong>\nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".\n</pre>\n\n<div>\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-2-1\">\"(()())(())(()(()))\"</span>\n<strong>Output: </strong><span id=\"example-output-2\">\"()()()()(())\"</span>\n<strong>Explanation: </strong>\nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".\n</pre>\n\n<div>\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input: </strong><span id=\"example-input-3-1\">\"()()\"</span>\n<strong>Output: </strong><span id=\"example-output-3\">\"\"</span>\n<strong>Explanation: </strong>\nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\".\n</pre>\n\n<p>&nbsp;</p>\n</div>\n</div>\n\n<p><strong>Note:</strong></p>\n\n<ol>\n\t<li><code>S.length &lt;= 10000</code></li>\n\t<li><code>S[i]</code> is <code>\"(\"</code> or <code>\")\"</code></li>\n\t<li><code>S</code> is a valid parentheses string</li>\n</ol>\n\n<div>\n<div>\n<div>&nbsp;</div>\n</div>\n</div></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    string removeOuterParentheses(string S)\n    {\n\n        int n = S.length();\n        char res[n];\n\n        fill_n(res, n, '\\0');\n\n        int pos = 0;\n        int diff = 0;\n        for (char i : S)\n        {\n\n            if (i == '(')\n            {\n                if (diff)\n                {\n                    res[pos] = '(';\n                    ++pos;\n                }\n                ++diff;\n            }\n            else\n            {\n                --diff;\n                if (diff)\n                {\n                    res[pos] = ')';\n                    ++pos;\n                }\n            }\n        }\n\n        string r(res);\n\n        return r;\n    }\n};", "number": "1021"}, "1295": {"link": "https://leetcode.com/problems/find-numbers-with-even-number-of-digits", "name": "Find Numbers with Even Number of Digits", "difficulty": "Easy", "statement": "<div>Given an array <code>nums</code> of integers, return how many of them contain an <strong>even number</strong> of digits.\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> nums = [12,345,2,6,7896]\n<strong>Output:</strong> 2\n<strong>Explanation: \n</strong>12 contains 2 digits (even number of digits).&nbsp;\n345 contains 3 digits (odd number of digits).&nbsp;\n2 contains 1 digit (odd number of digits).&nbsp;\n6 contains 1 digit (odd number of digits).&nbsp;\n7896 contains 4 digits (even number of digits).&nbsp;\nTherefore only 12 and 7896 contain an even number of digits.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> nums = [555,901,482,1771]\n<strong>Output:</strong> 1 \n<strong>Explanation: </strong>\nOnly 1771 contains an even number of digits.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include<iostream>\n#include<bits/stdc++.h>\n#include <cmath> \n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findNumbers(vector<int>& nums) {\n\n        int count = 0;\n        for (int i: nums) {\n            if ((int)ceil(log10(i+1)) % 2 == 0)\n                count ++;\n        }\n\n        return count;\n        \n    }\n};", "number": "1295"}, "1380": {"link": "https://leetcode.com/problems/lucky-numbers-in-a-matrix", "name": "Lucky Numbers in a Matrix", "difficulty": "Easy", "statement": "<div><p>Given a <code>m * n</code> matrix of <strong>distinct </strong>numbers, return all lucky numbers in the&nbsp;matrix in <strong>any </strong>order.</p>\n\n<p>A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> matrix = [[3,7,8],[9,11,13],[15,16,17]]\n<strong>Output:</strong> [15]\n<strong>Explanation:</strong> 15 is the only lucky number since it is the minimum in its row and the maximum in its column\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]\n<strong>Output:</strong> [12]\n<strong>Explanation:</strong> 12 is the only lucky number since it is the minimum in its row and the maximum in its column.\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> matrix = [[7,8],[1,2]]\n<strong>Output:</strong> [7]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 50</code></li>\n\t<li><code>1 &lt;=&nbsp;matrix[i][j]&nbsp;&lt;= 10^5</code>.</li>\n\t<li>All elements in the matrix are distinct.</li>\n</ul></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    vector<int> luckyNumbers(vector<vector<int>> &matrix)\n    {\n\n        int m = matrix.size();\n        int n = matrix[0].size();\n\n        int min_row[m];\n        int max_col[n];\n\n        fill_n(min_row, m, 1000000);\n        fill_n(max_col, n, 0);\n\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < n; j++)\n            {\n                min_row[i] = min_row[i] < matrix[i][j] ? min_row[i] : matrix[i][j];\n                max_col[j] = max_col[j] > matrix[i][j] ? max_col[j] : matrix[i][j];\n            }\n\n        vector<int> res;\n\n        for (int i = 0; i < m; i++)\n            for (int j = 0; j < n; j++)\n                if (min_row[i] == matrix[i][j] && max_col[j] == matrix[i][j])\n                    res.push_back(matrix[i][j]);\n        \n        return res;\n    }\n};", "number": "1380"}, "461": {"link": "https://leetcode.com/problems/hamming-distance", "name": "Hamming Distance", "difficulty": "Easy", "statement": "<div><p>The <a href=\"https://en.wikipedia.org/wiki/Hamming_distance\" target=\"_blank\">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p>\n\n<p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p>\n\n<p><b>Note:</b><br>\n0 \u2264 <code>x</code>, <code>y</code> &lt; 2<sup>31</sup>.\n</p>\n\n<p><b>Example:</b>\n</p><pre><b>Input:</b> x = 1, y = 4\n\n<b>Output:</b> 2\n\n<b>Explanation:</b>\n1   (0 0 0 1)\n4   (0 1 0 0)\n       \u2191   \u2191\n\nThe above arrows point to positions where the corresponding bits are different.\n</pre>\n<p></p></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n\n        int count  = 0;\n        while (x || y) {\n            if (x % 2 != y % 2) count ++;\n            x /= 2; y/= 2;\n        }\n\n        return count;\n        \n    }\n};", "number": "461"}, "728": {"link": "https://leetcode.com/problems/self-dividing-numbers", "name": "Self Dividing Numbers", "difficulty": "Easy", "statement": "<div><p>\nA <i>self-dividing number</i> is a number that is divisible by every digit it contains.\n</p><p>\nFor example, 128 is a self-dividing number because <code>128 % 1 == 0</code>, <code>128 % 2 == 0</code>, and <code>128 % 8 == 0</code>.\n</p><p>\nAlso, a self-dividing number is not allowed to contain the digit zero.\n</p><p>\nGiven a lower and upper number bound, output a list of every possible self dividing number, including the bounds if possible.\n</p>\n<p><b>Example 1:</b><br>\n</p><pre><b>Input:</b> \nleft = 1, right = 22\n<b>Output:</b> [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n</pre>\n<p></p>\n\n<p><b>Note:</b>\n</p><li>The boundaries of each input argument are <code>1 &lt;= left &lt;= right &lt;= 10000</code>.</li>\n<p></p></div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> selfDividingNumbers(int left, int right) {\n\n        vector<int> res;\n        for(int i = left; i <= right; i++) {\n\n            int isValid = 1;\n            int num = i;\n            while (num) {\n                int rem = num % 10;\n                if (rem == 0 || i % rem != 0) isValid = 0;\n                num /= 10;\n            }\n\n            if (isValid) res.push_back(i);\n\n        }\n\n        return res;\n        \n    }\n};", "number": "728"}, "804": {"link": "https://leetcode.com/problems/unique-morse-code-words", "name": "Unique Morse Code Words", "difficulty": "Easy", "statement": "<div><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>\"a\"</code> maps to <code>\".-\"</code>, <code>\"b\"</code> maps to <code>\"-...\"</code>, <code>\"c\"</code> maps to <code>\"-.-.\"</code>, and so on.</p>\n\n<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>\n\n<pre>[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]</pre>\n\n<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cab\" can be written as \"-.-..--...\", (which is the concatenation \"-.-.\" + \".-\" + \"<code>-...</code>\"). We'll call such a concatenation, the transformation&nbsp;of a word.</p>\n\n<p>Return the number of different transformations among all words we have.</p>\n\n<pre><strong>Example:</strong>\n<strong>Input:</strong> words = [\"gin\", \"zen\", \"gig\", \"msg\"]\n<strong>Output:</strong> 2\n<strong>Explanation: </strong>\nThe transformation of each word is:\n\"gin\" -&gt; \"--...-.\"\n\"zen\" -&gt; \"--...-.\"\n\"gig\" -&gt; \"--...--.\"\n\"msg\" -&gt; \"--...--.\"\n\nThere are 2 different transformations, \"--...-.\" and \"--...--.\".\n</pre>\n\n<p><strong>Note:</strong></p>\n\n<ul>\n\t<li>The length of <code>words</code> will be at most <code>100</code>.</li>\n\t<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>\n\t<li><code>words[i]</code> will only consist of lowercase letters.</li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int uniqueMorseRepresentations(vector<string> &words)\n    {\n\n        vector<string> codes;\n        int n = words.size();\n\n        string mapping[26] = {\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"};\n\n        for (string word : words)\n        {\n\n            stringstream r;\n\n            for (char c : word)\n            {\n                r << mapping[(int)(c)-97];\n            }\n\n            string res = r.str();\n            codes.push_back(res);\n        }\n\n        sort(codes.begin(), codes.end());\n\n        int count = n > 0 ? 1 : 0;\n\n        for (int i = 1; i < n; i++)\n        {\n            if (codes[i].compare(codes[i - 1]))\n                ++count;\n        }\n\n        return count;\n    }\n};", "number": "804"}, "944": {"link": "https://leetcode.com/problems/delete-columns-to-make-sorted", "name": "Delete Columns to Make Sorted", "difficulty": "Easy", "statement": "<div><p>We are given an array&nbsp;<code>A</code> of <code>N</code> lowercase letter strings, all of the same length.</p>\n\n<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>\n\n<p>For example, if we have an array <code>A = [\"abcdef\",\"uvwxyz\"]</code> and deletion indices <code>{0, 2, 3}</code>, then the final array after deletions is <code>[\"bef\", \"vyz\"]</code>,&nbsp;and the remaining columns of <code>A</code> are&nbsp;<code>[\"b\",\"v\"]</code>, <code>[\"e\",\"y\"]</code>, and <code>[\"f\",\"z\"]</code>.&nbsp; (Formally, the <code>c</code>-th column is <code>[A[0][c], A[1][c], ..., A[A.length-1][c]]</code>).</p>\n\n<p>Suppose we chose a set of deletion indices <code>D</code> such that after deletions, each remaining column in A is in <strong>non-decreasing</strong> sorted order.</p>\n\n<p>Return the minimum possible value of <code>D.length</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre><strong>Input:</strong> A = [\"cba\",\"daf\",\"ghi\"]\n<strong>Output:</strong> 1\n<strong>Explanation: </strong>\nAfter choosing D = {1}, each column [\"c\",\"d\",\"g\"] and [\"a\",\"f\",\"i\"] are in non-decreasing sorted order.\nIf we chose D = {}, then a column [\"b\",\"a\",\"h\"] would not be in non-decreasing sorted order.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre><strong>Input:</strong> A = [\"a\",\"b\"]\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>D = {}\n</pre>\n\n<p><strong>Example 3:</strong></p>\n\n<pre><strong>Input:</strong> A = [\"zyx\",\"wvu\",\"tsr\"]\n<strong>Output:</strong> 3\n<strong>Explanation: </strong>D = {0, 1, 2}\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= A.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= A[i].length &lt;= 1000</code></li>\n</ul>\n</div>", "language": "cpp", "solution": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int minDeletionSize(vector<string> &A)\n    {\n\n        int len = A[0].length();\n        int n = A.size();\n\n        int del[len];\n        fill_n(del, len, 0);\n\n        for(int i = 0; i < n-1; i++) {\n            for(int j = 0; j < len; j++) {\n                if (A[i][j] > A[i+1][j]) {\n                    del[j] = 1;\n                    \n                }\n            }\n        }\n\n        int count = 0;\n        for(int i: del)\n            count += i;\n\n        return count;\n\n    }\n};", "number": "944"}}